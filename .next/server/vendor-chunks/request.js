"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/request";
exports.ids = ["vendor-chunks/request"];
exports.modules = {

/***/ "(ssr)/./node_modules/request/index.js":
/*!***************************************!*\
  !*** ./node_modules/request/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2010-2012 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\n\n\nvar extend = __webpack_require__(/*! extend */ \"(ssr)/./node_modules/extend/index.js\")\nvar cookies = __webpack_require__(/*! ./lib/cookies */ \"(ssr)/./node_modules/request/lib/cookies.js\")\nvar helpers = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/request/lib/helpers.js\")\n\nvar paramsHaveRequestBody = helpers.paramsHaveRequestBody\n\n// organize params for patch, post, put, head, del\nfunction initParams (uri, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n  }\n\n  var params = {}\n  if (options !== null && typeof options === 'object') {\n    extend(params, options, {uri: uri})\n  } else if (typeof uri === 'string') {\n    extend(params, {uri: uri})\n  } else {\n    extend(params, uri)\n  }\n\n  params.callback = callback || params.callback\n  return params\n}\n\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') {\n    throw new Error('undefined is not a valid uri or options object.')\n  }\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {\n    throw new Error('HTTP HEAD requests MUST NOT include a request body.')\n  }\n\n  return new request.Request(params)\n}\n\nfunction verbFunc (verb) {\n  var method = verb.toUpperCase()\n  return function (uri, options, callback) {\n    var params = initParams(uri, options, callback)\n    params.method = method\n    return request(params, params.callback)\n  }\n}\n\n// define like this to please codeintel/intellisense IDEs\nrequest.get = verbFunc('get')\nrequest.head = verbFunc('head')\nrequest.options = verbFunc('options')\nrequest.post = verbFunc('post')\nrequest.put = verbFunc('put')\nrequest.patch = verbFunc('patch')\nrequest.del = verbFunc('delete')\nrequest['delete'] = verbFunc('delete')\n\nrequest.jar = function (store) {\n  return cookies.jar(store)\n}\n\nrequest.cookie = function (str) {\n  return cookies.parse(str)\n}\n\nfunction wrapRequestMethod (method, options, requester, verb) {\n  return function (uri, opts, callback) {\n    var params = initParams(uri, opts, callback)\n\n    var target = {}\n    extend(true, target, options, params)\n\n    target.pool = params.pool || options.pool\n\n    if (verb) {\n      target.method = verb.toUpperCase()\n    }\n\n    if (typeof requester === 'function') {\n      method = requester\n    }\n\n    return method(target, target.callback)\n  }\n}\n\nrequest.defaults = function (options, requester) {\n  var self = this\n\n  options = options || {}\n\n  if (typeof options === 'function') {\n    requester = options\n    options = {}\n  }\n\n  var defaults = wrapRequestMethod(self, options, requester)\n\n  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete']\n  verbs.forEach(function (verb) {\n    defaults[verb] = wrapRequestMethod(self[verb], options, requester, verb)\n  })\n\n  defaults.cookie = wrapRequestMethod(self.cookie, options, requester)\n  defaults.jar = self.jar\n  defaults.defaults = self.defaults\n  return defaults\n}\n\nrequest.forever = function (agentOptions, optionsArg) {\n  var options = {}\n  if (optionsArg) {\n    extend(options, optionsArg)\n  }\n  if (agentOptions) {\n    options.agentOptions = agentOptions\n  }\n\n  options.forever = true\n  return request.defaults(options)\n}\n\n// Exports\n\nmodule.exports = request\nrequest.Request = __webpack_require__(/*! ./request */ \"(ssr)/./node_modules/request/request.js\")\nrequest.initParams = initParams\n\n// Backwards compatibility for request.debug\nObject.defineProperty(request, 'debug', {\n  enumerable: true,\n  get: function () {\n    return request.Request.debug\n  },\n  set: function (debug) {\n    request.Request.debug = debug\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsb0RBQVE7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLGtFQUFlO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBZTs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEMsSUFBSTtBQUNKLG9CQUFvQixTQUFTO0FBQzdCLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMERBQVc7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlckZpbGVzXFxnaWZfYXBwXFxnaWZfYXBwXFxub2RlX21vZHVsZXNcXHJlcXVlc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEwLTIwMTIgTWlrZWFsIFJvZ2Vyc1xuLy9cbi8vICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyAgICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyAgICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQnKVxudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuL2xpYi9jb29raWVzJylcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9saWIvaGVscGVycycpXG5cbnZhciBwYXJhbXNIYXZlUmVxdWVzdEJvZHkgPSBoZWxwZXJzLnBhcmFtc0hhdmVSZXF1ZXN0Qm9keVxuXG4vLyBvcmdhbml6ZSBwYXJhbXMgZm9yIHBhdGNoLCBwb3N0LCBwdXQsIGhlYWQsIGRlbFxuZnVuY3Rpb24gaW5pdFBhcmFtcyAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgfVxuXG4gIHZhciBwYXJhbXMgPSB7fVxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICBleHRlbmQocGFyYW1zLCBvcHRpb25zLCB7dXJpOiB1cml9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgZXh0ZW5kKHBhcmFtcywge3VyaTogdXJpfSlcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQocGFyYW1zLCB1cmkpXG4gIH1cblxuICBwYXJhbXMuY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBwYXJhbXMuY2FsbGJhY2tcbiAgcmV0dXJuIHBhcmFtc1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0ICh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIHVyaSBvciBvcHRpb25zIG9iamVjdC4nKVxuICB9XG5cbiAgdmFyIHBhcmFtcyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcblxuICBpZiAocGFyYW1zLm1ldGhvZCA9PT0gJ0hFQUQnICYmIHBhcmFtc0hhdmVSZXF1ZXN0Qm9keShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIEhFQUQgcmVxdWVzdHMgTVVTVCBOT1QgaW5jbHVkZSBhIHJlcXVlc3QgYm9keS4nKVxuICB9XG5cbiAgcmV0dXJuIG5ldyByZXF1ZXN0LlJlcXVlc3QocGFyYW1zKVxufVxuXG5mdW5jdGlvbiB2ZXJiRnVuYyAodmVyYikge1xuICB2YXIgbWV0aG9kID0gdmVyYi50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgcGFyYW1zLm1ldGhvZCA9IG1ldGhvZFxuICAgIHJldHVybiByZXF1ZXN0KHBhcmFtcywgcGFyYW1zLmNhbGxiYWNrKVxuICB9XG59XG5cbi8vIGRlZmluZSBsaWtlIHRoaXMgdG8gcGxlYXNlIGNvZGVpbnRlbC9pbnRlbGxpc2Vuc2UgSURFc1xucmVxdWVzdC5nZXQgPSB2ZXJiRnVuYygnZ2V0JylcbnJlcXVlc3QuaGVhZCA9IHZlcmJGdW5jKCdoZWFkJylcbnJlcXVlc3Qub3B0aW9ucyA9IHZlcmJGdW5jKCdvcHRpb25zJylcbnJlcXVlc3QucG9zdCA9IHZlcmJGdW5jKCdwb3N0JylcbnJlcXVlc3QucHV0ID0gdmVyYkZ1bmMoJ3B1dCcpXG5yZXF1ZXN0LnBhdGNoID0gdmVyYkZ1bmMoJ3BhdGNoJylcbnJlcXVlc3QuZGVsID0gdmVyYkZ1bmMoJ2RlbGV0ZScpXG5yZXF1ZXN0WydkZWxldGUnXSA9IHZlcmJGdW5jKCdkZWxldGUnKVxuXG5yZXF1ZXN0LmphciA9IGZ1bmN0aW9uIChzdG9yZSkge1xuICByZXR1cm4gY29va2llcy5qYXIoc3RvcmUpXG59XG5cbnJlcXVlc3QuY29va2llID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gY29va2llcy5wYXJzZShzdHIpXG59XG5cbmZ1bmN0aW9uIHdyYXBSZXF1ZXN0TWV0aG9kIChtZXRob2QsIG9wdGlvbnMsIHJlcXVlc3RlciwgdmVyYikge1xuICByZXR1cm4gZnVuY3Rpb24gKHVyaSwgb3B0cywgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdHMsIGNhbGxiYWNrKVxuXG4gICAgdmFyIHRhcmdldCA9IHt9XG4gICAgZXh0ZW5kKHRydWUsIHRhcmdldCwgb3B0aW9ucywgcGFyYW1zKVxuXG4gICAgdGFyZ2V0LnBvb2wgPSBwYXJhbXMucG9vbCB8fCBvcHRpb25zLnBvb2xcblxuICAgIGlmICh2ZXJiKSB7XG4gICAgICB0YXJnZXQubWV0aG9kID0gdmVyYi50b1VwcGVyQ2FzZSgpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1ldGhvZCA9IHJlcXVlc3RlclxuICAgIH1cblxuICAgIHJldHVybiBtZXRob2QodGFyZ2V0LCB0YXJnZXQuY2FsbGJhY2spXG4gIH1cbn1cblxucmVxdWVzdC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXF1ZXN0ZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXF1ZXN0ZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB2YXIgZGVmYXVsdHMgPSB3cmFwUmVxdWVzdE1ldGhvZChzZWxmLCBvcHRpb25zLCByZXF1ZXN0ZXIpXG5cbiAgdmFyIHZlcmJzID0gWydnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdkZWwnLCAnZGVsZXRlJ11cbiAgdmVyYnMuZm9yRWFjaChmdW5jdGlvbiAodmVyYikge1xuICAgIGRlZmF1bHRzW3ZlcmJdID0gd3JhcFJlcXVlc3RNZXRob2Qoc2VsZlt2ZXJiXSwgb3B0aW9ucywgcmVxdWVzdGVyLCB2ZXJiKVxuICB9KVxuXG4gIGRlZmF1bHRzLmNvb2tpZSA9IHdyYXBSZXF1ZXN0TWV0aG9kKHNlbGYuY29va2llLCBvcHRpb25zLCByZXF1ZXN0ZXIpXG4gIGRlZmF1bHRzLmphciA9IHNlbGYuamFyXG4gIGRlZmF1bHRzLmRlZmF1bHRzID0gc2VsZi5kZWZhdWx0c1xuICByZXR1cm4gZGVmYXVsdHNcbn1cblxucmVxdWVzdC5mb3JldmVyID0gZnVuY3Rpb24gKGFnZW50T3B0aW9ucywgb3B0aW9uc0FyZykge1xuICB2YXIgb3B0aW9ucyA9IHt9XG4gIGlmIChvcHRpb25zQXJnKSB7XG4gICAgZXh0ZW5kKG9wdGlvbnMsIG9wdGlvbnNBcmcpXG4gIH1cbiAgaWYgKGFnZW50T3B0aW9ucykge1xuICAgIG9wdGlvbnMuYWdlbnRPcHRpb25zID0gYWdlbnRPcHRpb25zXG4gIH1cblxuICBvcHRpb25zLmZvcmV2ZXIgPSB0cnVlXG4gIHJldHVybiByZXF1ZXN0LmRlZmF1bHRzKG9wdGlvbnMpXG59XG5cbi8vIEV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0XG5yZXF1ZXN0LlJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKVxucmVxdWVzdC5pbml0UGFyYW1zID0gaW5pdFBhcmFtc1xuXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgcmVxdWVzdC5kZWJ1Z1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICdkZWJ1ZycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QuUmVxdWVzdC5kZWJ1Z1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChkZWJ1Zykge1xuICAgIHJlcXVlc3QuUmVxdWVzdC5kZWJ1ZyA9IGRlYnVnXG4gIH1cbn0pXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/auth.js":
/*!******************************************!*\
  !*** ./node_modules/request/lib/auth.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar caseless = __webpack_require__(/*! caseless */ \"(ssr)/./node_modules/caseless/index.js\")\nvar uuid = __webpack_require__(/*! uuid/v4 */ \"(ssr)/./node_modules/uuid/v4.js\")\nvar helpers = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/request/lib/helpers.js\")\n\nvar md5 = helpers.md5\nvar toBase64 = helpers.toBase64\n\nfunction Auth (request) {\n  // define all public properties here\n  this.request = request\n  this.hasAuth = false\n  this.sentAuth = false\n  this.bearerToken = null\n  this.user = null\n  this.pass = null\n}\n\nAuth.prototype.basic = function (user, pass, sendImmediately) {\n  var self = this\n  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {\n    self.request.emit('error', new Error('auth() received invalid user or password'))\n  }\n  self.user = user\n  self.pass = pass\n  self.hasAuth = true\n  var header = user + ':' + (pass || '')\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    var authHeader = 'Basic ' + toBase64(header)\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.bearer = function (bearer, sendImmediately) {\n  var self = this\n  self.bearerToken = bearer\n  self.hasAuth = true\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    if (typeof bearer === 'function') {\n      bearer = bearer()\n    }\n    var authHeader = 'Bearer ' + (bearer || '')\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.digest = function (method, path, authHeader) {\n  // TODO: More complete implementation of RFC 2617.\n  //   - handle challenge.domain\n  //   - support qop=\"auth-int\" only\n  //   - handle Authentication-Info (not necessarily?)\n  //   - check challenge.stale (not necessarily?)\n  //   - increase nc (not necessarily?)\n  // For reference:\n  // http://tools.ietf.org/html/rfc2617#section-3\n  // https://github.com/bagder/curl/blob/master/lib/http_digest.c\n\n  var self = this\n\n  var challenge = {}\n  var re = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/gi\n  while (true) {\n    var match = re.exec(authHeader)\n    if (!match) {\n      break\n    }\n    challenge[match[1]] = match[2] || match[3]\n  }\n\n  /**\n   * RFC 2617: handle both MD5 and MD5-sess algorithms.\n   *\n   * If the algorithm directive's value is \"MD5\" or unspecified, then HA1 is\n   *   HA1=MD5(username:realm:password)\n   * If the algorithm directive's value is \"MD5-sess\", then HA1 is\n   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)\n   */\n  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {\n    var ha1 = md5(user + ':' + realm + ':' + pass)\n    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {\n      return md5(ha1 + ':' + nonce + ':' + cnonce)\n    } else {\n      return ha1\n    }\n  }\n\n  var qop = /(^|,)\\s*auth\\s*($|,)/.test(challenge.qop) && 'auth'\n  var nc = qop && '00000001'\n  var cnonce = qop && uuid().replace(/-/g, '')\n  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)\n  var ha2 = md5(method + ':' + path)\n  var digestResponse = qop\n    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)\n    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)\n  var authValues = {\n    username: self.user,\n    realm: challenge.realm,\n    nonce: challenge.nonce,\n    uri: path,\n    qop: qop,\n    response: digestResponse,\n    nc: nc,\n    cnonce: cnonce,\n    algorithm: challenge.algorithm,\n    opaque: challenge.opaque\n  }\n\n  authHeader = []\n  for (var k in authValues) {\n    if (authValues[k]) {\n      if (k === 'qop' || k === 'nc' || k === 'algorithm') {\n        authHeader.push(k + '=' + authValues[k])\n      } else {\n        authHeader.push(k + '=\"' + authValues[k] + '\"')\n      }\n    }\n  }\n  authHeader = 'Digest ' + authHeader.join(', ')\n  self.sentAuth = true\n  return authHeader\n}\n\nAuth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {\n  var self = this\n  var request = self.request\n\n  var authHeader\n  if (bearer === undefined && user === undefined) {\n    self.request.emit('error', new Error('no auth mechanism defined'))\n  } else if (bearer !== undefined) {\n    authHeader = self.bearer(bearer, sendImmediately)\n  } else {\n    authHeader = self.basic(user, pass, sendImmediately)\n  }\n  if (authHeader) {\n    request.setHeader('authorization', authHeader)\n  }\n}\n\nAuth.prototype.onResponse = function (response) {\n  var self = this\n  var request = self.request\n\n  if (!self.hasAuth || self.sentAuth) { return null }\n\n  var c = caseless(response.headers)\n\n  var authHeader = c.get('www-authenticate')\n  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()\n  request.debug('reauth', authVerb)\n\n  switch (authVerb) {\n    case 'basic':\n      return self.basic(self.user, self.pass, true)\n\n    case 'bearer':\n      return self.bearer(self.bearerToken, true)\n\n    case 'digest':\n      return self.digest(request.method, request.path, authHeader)\n  }\n}\n\nexports.Auth = Auth\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvYXV0aC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLGdEQUFTO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyw4REFBVzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZIiwic291cmNlcyI6WyJDOlxcVXNlckZpbGVzXFxnaWZfYXBwXFxnaWZfYXBwXFxub2RlX21vZHVsZXNcXHJlcXVlc3RcXGxpYlxcYXV0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIGNhc2VsZXNzID0gcmVxdWlyZSgnY2FzZWxlc3MnKVxudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3Y0JylcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJylcblxudmFyIG1kNSA9IGhlbHBlcnMubWQ1XG52YXIgdG9CYXNlNjQgPSBoZWxwZXJzLnRvQmFzZTY0XG5cbmZ1bmN0aW9uIEF1dGggKHJlcXVlc3QpIHtcbiAgLy8gZGVmaW5lIGFsbCBwdWJsaWMgcHJvcGVydGllcyBoZXJlXG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgdGhpcy5oYXNBdXRoID0gZmFsc2VcbiAgdGhpcy5zZW50QXV0aCA9IGZhbHNlXG4gIHRoaXMuYmVhcmVyVG9rZW4gPSBudWxsXG4gIHRoaXMudXNlciA9IG51bGxcbiAgdGhpcy5wYXNzID0gbnVsbFxufVxuXG5BdXRoLnByb3RvdHlwZS5iYXNpYyA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICh0eXBlb2YgdXNlciAhPT0gJ3N0cmluZycgfHwgKHBhc3MgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFzcyAhPT0gJ3N0cmluZycpKSB7XG4gICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdhdXRoKCkgcmVjZWl2ZWQgaW52YWxpZCB1c2VyIG9yIHBhc3N3b3JkJykpXG4gIH1cbiAgc2VsZi51c2VyID0gdXNlclxuICBzZWxmLnBhc3MgPSBwYXNzXG4gIHNlbGYuaGFzQXV0aCA9IHRydWVcbiAgdmFyIGhlYWRlciA9IHVzZXIgKyAnOicgKyAocGFzcyB8fCAnJylcbiAgaWYgKHNlbmRJbW1lZGlhdGVseSB8fCB0eXBlb2Ygc2VuZEltbWVkaWF0ZWx5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBhdXRoSGVhZGVyID0gJ0Jhc2ljICcgKyB0b0Jhc2U2NChoZWFkZXIpXG4gICAgc2VsZi5zZW50QXV0aCA9IHRydWVcbiAgICByZXR1cm4gYXV0aEhlYWRlclxuICB9XG59XG5cbkF1dGgucHJvdG90eXBlLmJlYXJlciA9IGZ1bmN0aW9uIChiZWFyZXIsIHNlbmRJbW1lZGlhdGVseSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5iZWFyZXJUb2tlbiA9IGJlYXJlclxuICBzZWxmLmhhc0F1dGggPSB0cnVlXG4gIGlmIChzZW5kSW1tZWRpYXRlbHkgfHwgdHlwZW9mIHNlbmRJbW1lZGlhdGVseSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGJlYXJlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYmVhcmVyID0gYmVhcmVyKClcbiAgICB9XG4gICAgdmFyIGF1dGhIZWFkZXIgPSAnQmVhcmVyICcgKyAoYmVhcmVyIHx8ICcnKVxuICAgIHNlbGYuc2VudEF1dGggPSB0cnVlXG4gICAgcmV0dXJuIGF1dGhIZWFkZXJcbiAgfVxufVxuXG5BdXRoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXRoLCBhdXRoSGVhZGVyKSB7XG4gIC8vIFRPRE86IE1vcmUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgUkZDIDI2MTcuXG4gIC8vICAgLSBoYW5kbGUgY2hhbGxlbmdlLmRvbWFpblxuICAvLyAgIC0gc3VwcG9ydCBxb3A9XCJhdXRoLWludFwiIG9ubHlcbiAgLy8gICAtIGhhbmRsZSBBdXRoZW50aWNhdGlvbi1JbmZvIChub3QgbmVjZXNzYXJpbHk/KVxuICAvLyAgIC0gY2hlY2sgY2hhbGxlbmdlLnN0YWxlIChub3QgbmVjZXNzYXJpbHk/KVxuICAvLyAgIC0gaW5jcmVhc2UgbmMgKG5vdCBuZWNlc3NhcmlseT8pXG4gIC8vIEZvciByZWZlcmVuY2U6XG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTcjc2VjdGlvbi0zXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWdkZXIvY3VybC9ibG9iL21hc3Rlci9saWIvaHR0cF9kaWdlc3QuY1xuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBjaGFsbGVuZ2UgPSB7fVxuICB2YXIgcmUgPSAvKFthLXowLTlfLV0rKT0oPzpcIihbXlwiXSspXCJ8KFthLXowLTlfLV0rKSkvZ2lcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbWF0Y2ggPSByZS5leGVjKGF1dGhIZWFkZXIpXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2hhbGxlbmdlW21hdGNoWzFdXSA9IG1hdGNoWzJdIHx8IG1hdGNoWzNdXG4gIH1cblxuICAvKipcbiAgICogUkZDIDI2MTc6IGhhbmRsZSBib3RoIE1ENSBhbmQgTUQ1LXNlc3MgYWxnb3JpdGhtcy5cbiAgICpcbiAgICogSWYgdGhlIGFsZ29yaXRobSBkaXJlY3RpdmUncyB2YWx1ZSBpcyBcIk1ENVwiIG9yIHVuc3BlY2lmaWVkLCB0aGVuIEhBMSBpc1xuICAgKiAgIEhBMT1NRDUodXNlcm5hbWU6cmVhbG06cGFzc3dvcmQpXG4gICAqIElmIHRoZSBhbGdvcml0aG0gZGlyZWN0aXZlJ3MgdmFsdWUgaXMgXCJNRDUtc2Vzc1wiLCB0aGVuIEhBMSBpc1xuICAgKiAgIEhBMT1NRDUoTUQ1KHVzZXJuYW1lOnJlYWxtOnBhc3N3b3JkKTpub25jZTpjbm9uY2UpXG4gICAqL1xuICB2YXIgaGExQ29tcHV0ZSA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIHVzZXIsIHJlYWxtLCBwYXNzLCBub25jZSwgY25vbmNlKSB7XG4gICAgdmFyIGhhMSA9IG1kNSh1c2VyICsgJzonICsgcmVhbG0gKyAnOicgKyBwYXNzKVxuICAgIGlmIChhbGdvcml0aG0gJiYgYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCkgPT09ICdtZDUtc2VzcycpIHtcbiAgICAgIHJldHVybiBtZDUoaGExICsgJzonICsgbm9uY2UgKyAnOicgKyBjbm9uY2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoYTFcbiAgICB9XG4gIH1cblxuICB2YXIgcW9wID0gLyhefCwpXFxzKmF1dGhcXHMqKCR8LCkvLnRlc3QoY2hhbGxlbmdlLnFvcCkgJiYgJ2F1dGgnXG4gIHZhciBuYyA9IHFvcCAmJiAnMDAwMDAwMDEnXG4gIHZhciBjbm9uY2UgPSBxb3AgJiYgdXVpZCgpLnJlcGxhY2UoLy0vZywgJycpXG4gIHZhciBoYTEgPSBoYTFDb21wdXRlKGNoYWxsZW5nZS5hbGdvcml0aG0sIHNlbGYudXNlciwgY2hhbGxlbmdlLnJlYWxtLCBzZWxmLnBhc3MsIGNoYWxsZW5nZS5ub25jZSwgY25vbmNlKVxuICB2YXIgaGEyID0gbWQ1KG1ldGhvZCArICc6JyArIHBhdGgpXG4gIHZhciBkaWdlc3RSZXNwb25zZSA9IHFvcFxuICAgID8gbWQ1KGhhMSArICc6JyArIGNoYWxsZW5nZS5ub25jZSArICc6JyArIG5jICsgJzonICsgY25vbmNlICsgJzonICsgcW9wICsgJzonICsgaGEyKVxuICAgIDogbWQ1KGhhMSArICc6JyArIGNoYWxsZW5nZS5ub25jZSArICc6JyArIGhhMilcbiAgdmFyIGF1dGhWYWx1ZXMgPSB7XG4gICAgdXNlcm5hbWU6IHNlbGYudXNlcixcbiAgICByZWFsbTogY2hhbGxlbmdlLnJlYWxtLFxuICAgIG5vbmNlOiBjaGFsbGVuZ2Uubm9uY2UsXG4gICAgdXJpOiBwYXRoLFxuICAgIHFvcDogcW9wLFxuICAgIHJlc3BvbnNlOiBkaWdlc3RSZXNwb25zZSxcbiAgICBuYzogbmMsXG4gICAgY25vbmNlOiBjbm9uY2UsXG4gICAgYWxnb3JpdGhtOiBjaGFsbGVuZ2UuYWxnb3JpdGhtLFxuICAgIG9wYXF1ZTogY2hhbGxlbmdlLm9wYXF1ZVxuICB9XG5cbiAgYXV0aEhlYWRlciA9IFtdXG4gIGZvciAodmFyIGsgaW4gYXV0aFZhbHVlcykge1xuICAgIGlmIChhdXRoVmFsdWVzW2tdKSB7XG4gICAgICBpZiAoayA9PT0gJ3FvcCcgfHwgayA9PT0gJ25jJyB8fCBrID09PSAnYWxnb3JpdGhtJykge1xuICAgICAgICBhdXRoSGVhZGVyLnB1c2goayArICc9JyArIGF1dGhWYWx1ZXNba10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRoSGVhZGVyLnB1c2goayArICc9XCInICsgYXV0aFZhbHVlc1trXSArICdcIicpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGF1dGhIZWFkZXIgPSAnRGlnZXN0ICcgKyBhdXRoSGVhZGVyLmpvaW4oJywgJylcbiAgc2VsZi5zZW50QXV0aCA9IHRydWVcbiAgcmV0dXJuIGF1dGhIZWFkZXJcbn1cblxuQXV0aC5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIHNlbmRJbW1lZGlhdGVseSwgYmVhcmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmVxdWVzdCA9IHNlbGYucmVxdWVzdFxuXG4gIHZhciBhdXRoSGVhZGVyXG4gIGlmIChiZWFyZXIgPT09IHVuZGVmaW5lZCAmJiB1c2VyID09PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIGF1dGggbWVjaGFuaXNtIGRlZmluZWQnKSlcbiAgfSBlbHNlIGlmIChiZWFyZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGF1dGhIZWFkZXIgPSBzZWxmLmJlYXJlcihiZWFyZXIsIHNlbmRJbW1lZGlhdGVseSlcbiAgfSBlbHNlIHtcbiAgICBhdXRoSGVhZGVyID0gc2VsZi5iYXNpYyh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHkpXG4gIH1cbiAgaWYgKGF1dGhIZWFkZXIpIHtcbiAgICByZXF1ZXN0LnNldEhlYWRlcignYXV0aG9yaXphdGlvbicsIGF1dGhIZWFkZXIpXG4gIH1cbn1cblxuQXV0aC5wcm90b3R5cGUub25SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICBpZiAoIXNlbGYuaGFzQXV0aCB8fCBzZWxmLnNlbnRBdXRoKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgYyA9IGNhc2VsZXNzKHJlc3BvbnNlLmhlYWRlcnMpXG5cbiAgdmFyIGF1dGhIZWFkZXIgPSBjLmdldCgnd3d3LWF1dGhlbnRpY2F0ZScpXG4gIHZhciBhdXRoVmVyYiA9IGF1dGhIZWFkZXIgJiYgYXV0aEhlYWRlci5zcGxpdCgnICcpWzBdLnRvTG93ZXJDYXNlKClcbiAgcmVxdWVzdC5kZWJ1ZygncmVhdXRoJywgYXV0aFZlcmIpXG5cbiAgc3dpdGNoIChhdXRoVmVyYikge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHJldHVybiBzZWxmLmJhc2ljKHNlbGYudXNlciwgc2VsZi5wYXNzLCB0cnVlKVxuXG4gICAgY2FzZSAnYmVhcmVyJzpcbiAgICAgIHJldHVybiBzZWxmLmJlYXJlcihzZWxmLmJlYXJlclRva2VuLCB0cnVlKVxuXG4gICAgY2FzZSAnZGlnZXN0JzpcbiAgICAgIHJldHVybiBzZWxmLmRpZ2VzdChyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC5wYXRoLCBhdXRoSGVhZGVyKVxuICB9XG59XG5cbmV4cG9ydHMuQXV0aCA9IEF1dGhcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/auth.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/cookies.js":
/*!*********************************************!*\
  !*** ./node_modules/request/lib/cookies.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar tough = __webpack_require__(/*! tough-cookie */ \"(ssr)/./node_modules/tough-cookie/lib/cookie.js\")\n\nvar Cookie = tough.Cookie\nvar CookieJar = tough.CookieJar\n\nexports.parse = function (str) {\n  if (str && str.uri) {\n    str = str.uri\n  }\n  if (typeof str !== 'string') {\n    throw new Error('The cookie function only accepts STRING as param')\n  }\n  return Cookie.parse(str, {loose: true})\n}\n\n// Adapt the sometimes-Async api of tough.CookieJar to our requirements\nfunction RequestJar (store) {\n  var self = this\n  self._jar = new CookieJar(store, {looseMode: true})\n}\nRequestJar.prototype.setCookie = function (cookieOrStr, uri, options) {\n  var self = this\n  return self._jar.setCookieSync(cookieOrStr, uri, options || {})\n}\nRequestJar.prototype.getCookieString = function (uri) {\n  var self = this\n  return self._jar.getCookieStringSync(uri)\n}\nRequestJar.prototype.getCookies = function (uri) {\n  var self = this\n  return self._jar.getCookiesSync(uri)\n}\n\nexports.jar = function (store) {\n  return new RequestJar(store)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixZQUFZLG1CQUFPLENBQUMscUVBQWM7O0FBRWxDO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJGaWxlc1xcZ2lmX2FwcFxcZ2lmX2FwcFxcbm9kZV9tb2R1bGVzXFxyZXF1ZXN0XFxsaWJcXGNvb2tpZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciB0b3VnaCA9IHJlcXVpcmUoJ3RvdWdoLWNvb2tpZScpXG5cbnZhciBDb29raWUgPSB0b3VnaC5Db29raWVcbnZhciBDb29raWVKYXIgPSB0b3VnaC5Db29raWVKYXJcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHN0ciAmJiBzdHIudXJpKSB7XG4gICAgc3RyID0gc3RyLnVyaVxuICB9XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvb2tpZSBmdW5jdGlvbiBvbmx5IGFjY2VwdHMgU1RSSU5HIGFzIHBhcmFtJylcbiAgfVxuICByZXR1cm4gQ29va2llLnBhcnNlKHN0ciwge2xvb3NlOiB0cnVlfSlcbn1cblxuLy8gQWRhcHQgdGhlIHNvbWV0aW1lcy1Bc3luYyBhcGkgb2YgdG91Z2guQ29va2llSmFyIHRvIG91ciByZXF1aXJlbWVudHNcbmZ1bmN0aW9uIFJlcXVlc3RKYXIgKHN0b3JlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9qYXIgPSBuZXcgQ29va2llSmFyKHN0b3JlLCB7bG9vc2VNb2RlOiB0cnVlfSlcbn1cblJlcXVlc3RKYXIucHJvdG90eXBlLnNldENvb2tpZSA9IGZ1bmN0aW9uIChjb29raWVPclN0ciwgdXJpLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4gc2VsZi5famFyLnNldENvb2tpZVN5bmMoY29va2llT3JTdHIsIHVyaSwgb3B0aW9ucyB8fCB7fSlcbn1cblJlcXVlc3RKYXIucHJvdG90eXBlLmdldENvb2tpZVN0cmluZyA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiBzZWxmLl9qYXIuZ2V0Q29va2llU3RyaW5nU3luYyh1cmkpXG59XG5SZXF1ZXN0SmFyLnByb3RvdHlwZS5nZXRDb29raWVzID0gZnVuY3Rpb24gKHVyaSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHNlbGYuX2phci5nZXRDb29raWVzU3luYyh1cmkpXG59XG5cbmV4cG9ydHMuamFyID0gZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdEphcihzdG9yZSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/cookies.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/getProxyFromURI.js":
/*!*****************************************************!*\
  !*** ./node_modules/request/lib/getProxyFromURI.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\nfunction formatHostname (hostname) {\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\n}\n\nfunction parseNoProxyZone (zone) {\n  zone = zone.trim().toLowerCase()\n\n  var zoneParts = zone.split(':', 2)\n  var zoneHost = formatHostname(zoneParts[0])\n  var zonePort = zoneParts[1]\n  var hasPort = zone.indexOf(':') > -1\n\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\n}\n\nfunction uriInNoProxy (uri, noProxy) {\n  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n  var hostname = formatHostname(uri.hostname)\n  var noProxyList = noProxy.split(',')\n\n  // iterate through the noProxyList until it finds a match.\n  return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {\n    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)\n    var hostnameMatched = (\n      isMatchedAt > -1 &&\n        (isMatchedAt === hostname.length - noProxyZone.hostname.length)\n    )\n\n    if (noProxyZone.hasPort) {\n      return (port === noProxyZone.port) && hostnameMatched\n    }\n\n    return hostnameMatched\n  })\n}\n\nfunction getProxyFromURI (uri) {\n  // Decide the proper request proxy to use based on the request URI object and the\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\n  // respect NO_PROXY environment variables (see: https://lynx.invisible-island.net/lynx2.8.7/breakout/lynx_help/keystrokes/environments.html)\n\n  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''\n\n  // if the noProxy is a wildcard then return null\n\n  if (noProxy === '*') {\n    return null\n  }\n\n  // if the noProxy is not empty and the uri is found return null\n\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\n    return null\n  }\n\n  // Check for HTTP or HTTPS Proxy in environment Else default to null\n\n  if (uri.protocol === 'http:') {\n    return process.env.HTTP_PROXY ||\n      process.env.http_proxy || null\n  }\n\n  if (uri.protocol === 'https:') {\n    return process.env.HTTPS_PROXY ||\n      process.env.https_proxy ||\n      process.env.HTTP_PROXY ||\n      process.env.http_proxy || null\n  }\n\n  // if none of that works, return null\n  // (What uri protocol are you using then?)\n\n  return null\n}\n\nmodule.exports = getProxyFromURI\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvZ2V0UHJveHlGcm9tVVJJLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2VyRmlsZXNcXGdpZl9hcHBcXGdpZl9hcHBcXG5vZGVfbW9kdWxlc1xccmVxdWVzdFxcbGliXFxnZXRQcm94eUZyb21VUkkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGZvcm1hdEhvc3RuYW1lIChob3N0bmFtZSkge1xuICAvLyBjYW5vbmljYWxpemUgdGhlIGhvc3RuYW1lLCBzbyB0aGF0ICdvb2dsZS5jb20nIHdvbid0IG1hdGNoICdnb29nbGUuY29tJ1xuICByZXR1cm4gaG9zdG5hbWUucmVwbGFjZSgvXlxcLiovLCAnLicpLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gcGFyc2VOb1Byb3h5Wm9uZSAoem9uZSkge1xuICB6b25lID0gem9uZS50cmltKCkudG9Mb3dlckNhc2UoKVxuXG4gIHZhciB6b25lUGFydHMgPSB6b25lLnNwbGl0KCc6JywgMilcbiAgdmFyIHpvbmVIb3N0ID0gZm9ybWF0SG9zdG5hbWUoem9uZVBhcnRzWzBdKVxuICB2YXIgem9uZVBvcnQgPSB6b25lUGFydHNbMV1cbiAgdmFyIGhhc1BvcnQgPSB6b25lLmluZGV4T2YoJzonKSA+IC0xXG5cbiAgcmV0dXJuIHtob3N0bmFtZTogem9uZUhvc3QsIHBvcnQ6IHpvbmVQb3J0LCBoYXNQb3J0OiBoYXNQb3J0fVxufVxuXG5mdW5jdGlvbiB1cmlJbk5vUHJveHkgKHVyaSwgbm9Qcm94eSkge1xuICB2YXIgcG9ydCA9IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gJzQ0MycgOiAnODAnKVxuICB2YXIgaG9zdG5hbWUgPSBmb3JtYXRIb3N0bmFtZSh1cmkuaG9zdG5hbWUpXG4gIHZhciBub1Byb3h5TGlzdCA9IG5vUHJveHkuc3BsaXQoJywnKVxuXG4gIC8vIGl0ZXJhdGUgdGhyb3VnaCB0aGUgbm9Qcm94eUxpc3QgdW50aWwgaXQgZmluZHMgYSBtYXRjaC5cbiAgcmV0dXJuIG5vUHJveHlMaXN0Lm1hcChwYXJzZU5vUHJveHlab25lKS5zb21lKGZ1bmN0aW9uIChub1Byb3h5Wm9uZSkge1xuICAgIHZhciBpc01hdGNoZWRBdCA9IGhvc3RuYW1lLmluZGV4T2Yobm9Qcm94eVpvbmUuaG9zdG5hbWUpXG4gICAgdmFyIGhvc3RuYW1lTWF0Y2hlZCA9IChcbiAgICAgIGlzTWF0Y2hlZEF0ID4gLTEgJiZcbiAgICAgICAgKGlzTWF0Y2hlZEF0ID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5Wm9uZS5ob3N0bmFtZS5sZW5ndGgpXG4gICAgKVxuXG4gICAgaWYgKG5vUHJveHlab25lLmhhc1BvcnQpIHtcbiAgICAgIHJldHVybiAocG9ydCA9PT0gbm9Qcm94eVpvbmUucG9ydCkgJiYgaG9zdG5hbWVNYXRjaGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RuYW1lTWF0Y2hlZFxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRQcm94eUZyb21VUkkgKHVyaSkge1xuICAvLyBEZWNpZGUgdGhlIHByb3BlciByZXF1ZXN0IHByb3h5IHRvIHVzZSBiYXNlZCBvbiB0aGUgcmVxdWVzdCBVUkkgb2JqZWN0IGFuZCB0aGVcbiAgLy8gZW52aXJvbm1lbnRhbCB2YXJpYWJsZXMgKE5PX1BST1hZLCBIVFRQX1BST1hZLCBldGMuKVxuICAvLyByZXNwZWN0IE5PX1BST1hZIGVudmlyb25tZW50IHZhcmlhYmxlcyAoc2VlOiBodHRwczovL2x5bnguaW52aXNpYmxlLWlzbGFuZC5uZXQvbHlueDIuOC43L2JyZWFrb3V0L2x5bnhfaGVscC9rZXlzdHJva2VzL2Vudmlyb25tZW50cy5odG1sKVxuXG4gIHZhciBub1Byb3h5ID0gcHJvY2Vzcy5lbnYuTk9fUFJPWFkgfHwgcHJvY2Vzcy5lbnYubm9fcHJveHkgfHwgJydcblxuICAvLyBpZiB0aGUgbm9Qcm94eSBpcyBhIHdpbGRjYXJkIHRoZW4gcmV0dXJuIG51bGxcblxuICBpZiAobm9Qcm94eSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIGlmIHRoZSBub1Byb3h5IGlzIG5vdCBlbXB0eSBhbmQgdGhlIHVyaSBpcyBmb3VuZCByZXR1cm4gbnVsbFxuXG4gIGlmIChub1Byb3h5ICE9PSAnJyAmJiB1cmlJbk5vUHJveHkodXJpLCBub1Byb3h5KSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDaGVjayBmb3IgSFRUUCBvciBIVFRQUyBQcm94eSBpbiBlbnZpcm9ubWVudCBFbHNlIGRlZmF1bHQgdG8gbnVsbFxuXG4gIGlmICh1cmkucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBudWxsXG4gIH1cblxuICBpZiAodXJpLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQU19QUk9YWSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHxcbiAgICAgIHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHxcbiAgICAgIHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgbnVsbFxuICB9XG5cbiAgLy8gaWYgbm9uZSBvZiB0aGF0IHdvcmtzLCByZXR1cm4gbnVsbFxuICAvLyAoV2hhdCB1cmkgcHJvdG9jb2wgYXJlIHlvdSB1c2luZyB0aGVuPylcblxuICByZXR1cm4gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3h5RnJvbVVSSVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/getProxyFromURI.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/har.js":
/*!*****************************************!*\
  !*** ./node_modules/request/lib/har.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar fs = __webpack_require__(/*! fs */ \"fs\")\nvar qs = __webpack_require__(/*! querystring */ \"querystring\")\nvar validate = __webpack_require__(/*! har-validator */ \"(ssr)/./node_modules/har-validator/lib/promise.js\")\nvar extend = __webpack_require__(/*! extend */ \"(ssr)/./node_modules/extend/index.js\")\n\nfunction Har (request) {\n  this.request = request\n}\n\nHar.prototype.reducer = function (obj, pair) {\n  // new property ?\n  if (obj[pair.name] === undefined) {\n    obj[pair.name] = pair.value\n    return obj\n  }\n\n  // existing? convert to array\n  var arr = [\n    obj[pair.name],\n    pair.value\n  ]\n\n  obj[pair.name] = arr\n\n  return obj\n}\n\nHar.prototype.prep = function (data) {\n  // construct utility properties\n  data.queryObj = {}\n  data.headersObj = {}\n  data.postData.jsonObj = false\n  data.postData.paramsObj = false\n\n  // construct query objects\n  if (data.queryString && data.queryString.length) {\n    data.queryObj = data.queryString.reduce(this.reducer, {})\n  }\n\n  // construct headers objects\n  if (data.headers && data.headers.length) {\n    // loweCase header keys\n    data.headersObj = data.headers.reduceRight(function (headers, header) {\n      headers[header.name] = header.value\n      return headers\n    }, {})\n  }\n\n  // construct Cookie header\n  if (data.cookies && data.cookies.length) {\n    var cookies = data.cookies.map(function (cookie) {\n      return cookie.name + '=' + cookie.value\n    })\n\n    if (cookies.length) {\n      data.headersObj.cookie = cookies.join('; ')\n    }\n  }\n\n  // prep body\n  function some (arr) {\n    return arr.some(function (type) {\n      return data.postData.mimeType.indexOf(type) === 0\n    })\n  }\n\n  if (some([\n    'multipart/mixed',\n    'multipart/related',\n    'multipart/form-data',\n    'multipart/alternative'])) {\n    // reset values\n    data.postData.mimeType = 'multipart/form-data'\n  } else if (some([\n    'application/x-www-form-urlencoded'])) {\n    if (!data.postData.params) {\n      data.postData.text = ''\n    } else {\n      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})\n\n      // always overwrite\n      data.postData.text = qs.stringify(data.postData.paramsObj)\n    }\n  } else if (some([\n    'text/json',\n    'text/x-json',\n    'application/json',\n    'application/x-json'])) {\n    data.postData.mimeType = 'application/json'\n\n    if (data.postData.text) {\n      try {\n        data.postData.jsonObj = JSON.parse(data.postData.text)\n      } catch (e) {\n        this.request.debug(e)\n\n        // force back to text/plain\n        data.postData.mimeType = 'text/plain'\n      }\n    }\n  }\n\n  return data\n}\n\nHar.prototype.options = function (options) {\n  // skip if no har property defined\n  if (!options.har) {\n    return options\n  }\n\n  var har = {}\n  extend(har, options.har)\n\n  // only process the first entry\n  if (har.log && har.log.entries) {\n    har = har.log.entries[0]\n  }\n\n  // add optional properties to make validation successful\n  har.url = har.url || options.url || options.uri || options.baseUrl || '/'\n  har.httpVersion = har.httpVersion || 'HTTP/1.1'\n  har.queryString = har.queryString || []\n  har.headers = har.headers || []\n  har.cookies = har.cookies || []\n  har.postData = har.postData || {}\n  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'\n\n  har.bodySize = 0\n  har.headersSize = 0\n  har.postData.size = 0\n\n  if (!validate.request(har)) {\n    return options\n  }\n\n  // clean up and get some utility properties\n  var req = this.prep(har)\n\n  // construct new options\n  if (req.url) {\n    options.url = req.url\n  }\n\n  if (req.method) {\n    options.method = req.method\n  }\n\n  if (Object.keys(req.queryObj).length) {\n    options.qs = req.queryObj\n  }\n\n  if (Object.keys(req.headersObj).length) {\n    options.headers = req.headersObj\n  }\n\n  function test (type) {\n    return req.postData.mimeType.indexOf(type) === 0\n  }\n  if (test('application/x-www-form-urlencoded')) {\n    options.form = req.postData.paramsObj\n  } else if (test('application/json')) {\n    if (req.postData.jsonObj) {\n      options.body = req.postData.jsonObj\n      options.json = true\n    }\n  } else if (test('multipart/form-data')) {\n    options.formData = {}\n\n    req.postData.params.forEach(function (param) {\n      var attachment = {}\n\n      if (!param.fileName && !param.contentType) {\n        options.formData[param.name] = param.value\n        return\n      }\n\n      // attempt to read from disk!\n      if (param.fileName && !param.value) {\n        attachment.value = fs.createReadStream(param.fileName)\n      } else if (param.value) {\n        attachment.value = param.value\n      }\n\n      if (param.fileName) {\n        attachment.options = {\n          filename: param.fileName,\n          contentType: param.contentType ? param.contentType : null\n        }\n      }\n\n      options.formData[param.name] = attachment\n    })\n  } else {\n    if (req.postData.text) {\n      options.body = req.postData.text\n    }\n  }\n\n  return options\n}\n\nexports.Har = Har\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGFyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFNBQVMsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5QixlQUFlLG1CQUFPLENBQUMsd0VBQWU7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLG9EQUFROztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVciLCJzb3VyY2VzIjpbIkM6XFxVc2VyRmlsZXNcXGdpZl9hcHBcXGdpZl9hcHBcXG5vZGVfbW9kdWxlc1xccmVxdWVzdFxcbGliXFxoYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJ2hhci12YWxpZGF0b3InKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZCcpXG5cbmZ1bmN0aW9uIEhhciAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG59XG5cbkhhci5wcm90b3R5cGUucmVkdWNlciA9IGZ1bmN0aW9uIChvYmosIHBhaXIpIHtcbiAgLy8gbmV3IHByb3BlcnR5ID9cbiAgaWYgKG9ialtwYWlyLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICBvYmpbcGFpci5uYW1lXSA9IHBhaXIudmFsdWVcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICAvLyBleGlzdGluZz8gY29udmVydCB0byBhcnJheVxuICB2YXIgYXJyID0gW1xuICAgIG9ialtwYWlyLm5hbWVdLFxuICAgIHBhaXIudmFsdWVcbiAgXVxuXG4gIG9ialtwYWlyLm5hbWVdID0gYXJyXG5cbiAgcmV0dXJuIG9ialxufVxuXG5IYXIucHJvdG90eXBlLnByZXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAvLyBjb25zdHJ1Y3QgdXRpbGl0eSBwcm9wZXJ0aWVzXG4gIGRhdGEucXVlcnlPYmogPSB7fVxuICBkYXRhLmhlYWRlcnNPYmogPSB7fVxuICBkYXRhLnBvc3REYXRhLmpzb25PYmogPSBmYWxzZVxuICBkYXRhLnBvc3REYXRhLnBhcmFtc09iaiA9IGZhbHNlXG5cbiAgLy8gY29uc3RydWN0IHF1ZXJ5IG9iamVjdHNcbiAgaWYgKGRhdGEucXVlcnlTdHJpbmcgJiYgZGF0YS5xdWVyeVN0cmluZy5sZW5ndGgpIHtcbiAgICBkYXRhLnF1ZXJ5T2JqID0gZGF0YS5xdWVyeVN0cmluZy5yZWR1Y2UodGhpcy5yZWR1Y2VyLCB7fSlcbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBoZWFkZXJzIG9iamVjdHNcbiAgaWYgKGRhdGEuaGVhZGVycyAmJiBkYXRhLmhlYWRlcnMubGVuZ3RoKSB7XG4gICAgLy8gbG93ZUNhc2UgaGVhZGVyIGtleXNcbiAgICBkYXRhLmhlYWRlcnNPYmogPSBkYXRhLmhlYWRlcnMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGhlYWRlcnMsIGhlYWRlcikge1xuICAgICAgaGVhZGVyc1toZWFkZXIubmFtZV0gPSBoZWFkZXIudmFsdWVcbiAgICAgIHJldHVybiBoZWFkZXJzXG4gICAgfSwge30pXG4gIH1cblxuICAvLyBjb25zdHJ1Y3QgQ29va2llIGhlYWRlclxuICBpZiAoZGF0YS5jb29raWVzICYmIGRhdGEuY29va2llcy5sZW5ndGgpIHtcbiAgICB2YXIgY29va2llcyA9IGRhdGEuY29va2llcy5tYXAoZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgICAgcmV0dXJuIGNvb2tpZS5uYW1lICsgJz0nICsgY29va2llLnZhbHVlXG4gICAgfSlcblxuICAgIGlmIChjb29raWVzLmxlbmd0aCkge1xuICAgICAgZGF0YS5oZWFkZXJzT2JqLmNvb2tpZSA9IGNvb2tpZXMuam9pbignOyAnKVxuICAgIH1cbiAgfVxuXG4gIC8vIHByZXAgYm9keVxuICBmdW5jdGlvbiBzb21lIChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBkYXRhLnBvc3REYXRhLm1pbWVUeXBlLmluZGV4T2YodHlwZSkgPT09IDBcbiAgICB9KVxuICB9XG5cbiAgaWYgKHNvbWUoW1xuICAgICdtdWx0aXBhcnQvbWl4ZWQnLFxuICAgICdtdWx0aXBhcnQvcmVsYXRlZCcsXG4gICAgJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICdtdWx0aXBhcnQvYWx0ZXJuYXRpdmUnXSkpIHtcbiAgICAvLyByZXNldCB2YWx1ZXNcbiAgICBkYXRhLnBvc3REYXRhLm1pbWVUeXBlID0gJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gIH0gZWxzZSBpZiAoc29tZShbXG4gICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCddKSkge1xuICAgIGlmICghZGF0YS5wb3N0RGF0YS5wYXJhbXMpIHtcbiAgICAgIGRhdGEucG9zdERhdGEudGV4dCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEucG9zdERhdGEucGFyYW1zT2JqID0gZGF0YS5wb3N0RGF0YS5wYXJhbXMucmVkdWNlKHRoaXMucmVkdWNlciwge30pXG5cbiAgICAgIC8vIGFsd2F5cyBvdmVyd3JpdGVcbiAgICAgIGRhdGEucG9zdERhdGEudGV4dCA9IHFzLnN0cmluZ2lmeShkYXRhLnBvc3REYXRhLnBhcmFtc09iailcbiAgICB9XG4gIH0gZWxzZSBpZiAoc29tZShbXG4gICAgJ3RleHQvanNvbicsXG4gICAgJ3RleHQveC1qc29uJyxcbiAgICAnYXBwbGljYXRpb24vanNvbicsXG4gICAgJ2FwcGxpY2F0aW9uL3gtanNvbiddKSkge1xuICAgIGRhdGEucG9zdERhdGEubWltZVR5cGUgPSAnYXBwbGljYXRpb24vanNvbidcblxuICAgIGlmIChkYXRhLnBvc3REYXRhLnRleHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEucG9zdERhdGEuanNvbk9iaiA9IEpTT04ucGFyc2UoZGF0YS5wb3N0RGF0YS50ZXh0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnJlcXVlc3QuZGVidWcoZSlcblxuICAgICAgICAvLyBmb3JjZSBiYWNrIHRvIHRleHQvcGxhaW5cbiAgICAgICAgZGF0YS5wb3N0RGF0YS5taW1lVHlwZSA9ICd0ZXh0L3BsYWluJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhXG59XG5cbkhhci5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIHNraXAgaWYgbm8gaGFyIHByb3BlcnR5IGRlZmluZWRcbiAgaWYgKCFvcHRpb25zLmhhcikge1xuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICB2YXIgaGFyID0ge31cbiAgZXh0ZW5kKGhhciwgb3B0aW9ucy5oYXIpXG5cbiAgLy8gb25seSBwcm9jZXNzIHRoZSBmaXJzdCBlbnRyeVxuICBpZiAoaGFyLmxvZyAmJiBoYXIubG9nLmVudHJpZXMpIHtcbiAgICBoYXIgPSBoYXIubG9nLmVudHJpZXNbMF1cbiAgfVxuXG4gIC8vIGFkZCBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIG1ha2UgdmFsaWRhdGlvbiBzdWNjZXNzZnVsXG4gIGhhci51cmwgPSBoYXIudXJsIHx8IG9wdGlvbnMudXJsIHx8IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMuYmFzZVVybCB8fCAnLydcbiAgaGFyLmh0dHBWZXJzaW9uID0gaGFyLmh0dHBWZXJzaW9uIHx8ICdIVFRQLzEuMSdcbiAgaGFyLnF1ZXJ5U3RyaW5nID0gaGFyLnF1ZXJ5U3RyaW5nIHx8IFtdXG4gIGhhci5oZWFkZXJzID0gaGFyLmhlYWRlcnMgfHwgW11cbiAgaGFyLmNvb2tpZXMgPSBoYXIuY29va2llcyB8fCBbXVxuICBoYXIucG9zdERhdGEgPSBoYXIucG9zdERhdGEgfHwge31cbiAgaGFyLnBvc3REYXRhLm1pbWVUeXBlID0gaGFyLnBvc3REYXRhLm1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG5cbiAgaGFyLmJvZHlTaXplID0gMFxuICBoYXIuaGVhZGVyc1NpemUgPSAwXG4gIGhhci5wb3N0RGF0YS5zaXplID0gMFxuXG4gIGlmICghdmFsaWRhdGUucmVxdWVzdChoYXIpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8vIGNsZWFuIHVwIGFuZCBnZXQgc29tZSB1dGlsaXR5IHByb3BlcnRpZXNcbiAgdmFyIHJlcSA9IHRoaXMucHJlcChoYXIpXG5cbiAgLy8gY29uc3RydWN0IG5ldyBvcHRpb25zXG4gIGlmIChyZXEudXJsKSB7XG4gICAgb3B0aW9ucy51cmwgPSByZXEudXJsXG4gIH1cblxuICBpZiAocmVxLm1ldGhvZCkge1xuICAgIG9wdGlvbnMubWV0aG9kID0gcmVxLm1ldGhvZFxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHJlcS5xdWVyeU9iaikubGVuZ3RoKSB7XG4gICAgb3B0aW9ucy5xcyA9IHJlcS5xdWVyeU9ialxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHJlcS5oZWFkZXJzT2JqKS5sZW5ndGgpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSByZXEuaGVhZGVyc09ialxuICB9XG5cbiAgZnVuY3Rpb24gdGVzdCAodHlwZSkge1xuICAgIHJldHVybiByZXEucG9zdERhdGEubWltZVR5cGUuaW5kZXhPZih0eXBlKSA9PT0gMFxuICB9XG4gIGlmICh0ZXN0KCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSkge1xuICAgIG9wdGlvbnMuZm9ybSA9IHJlcS5wb3N0RGF0YS5wYXJhbXNPYmpcbiAgfSBlbHNlIGlmICh0ZXN0KCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICBpZiAocmVxLnBvc3REYXRhLmpzb25PYmopIHtcbiAgICAgIG9wdGlvbnMuYm9keSA9IHJlcS5wb3N0RGF0YS5qc29uT2JqXG4gICAgICBvcHRpb25zLmpzb24gPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKHRlc3QoJ211bHRpcGFydC9mb3JtLWRhdGEnKSkge1xuICAgIG9wdGlvbnMuZm9ybURhdGEgPSB7fVxuXG4gICAgcmVxLnBvc3REYXRhLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGF0dGFjaG1lbnQgPSB7fVxuXG4gICAgICBpZiAoIXBhcmFtLmZpbGVOYW1lICYmICFwYXJhbS5jb250ZW50VHlwZSkge1xuICAgICAgICBvcHRpb25zLmZvcm1EYXRhW3BhcmFtLm5hbWVdID0gcGFyYW0udmFsdWVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCBmcm9tIGRpc2shXG4gICAgICBpZiAocGFyYW0uZmlsZU5hbWUgJiYgIXBhcmFtLnZhbHVlKSB7XG4gICAgICAgIGF0dGFjaG1lbnQudmFsdWUgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhcmFtLmZpbGVOYW1lKVxuICAgICAgfSBlbHNlIGlmIChwYXJhbS52YWx1ZSkge1xuICAgICAgICBhdHRhY2htZW50LnZhbHVlID0gcGFyYW0udmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtLmZpbGVOYW1lKSB7XG4gICAgICAgIGF0dGFjaG1lbnQub3B0aW9ucyA9IHtcbiAgICAgICAgICBmaWxlbmFtZTogcGFyYW0uZmlsZU5hbWUsXG4gICAgICAgICAgY29udGVudFR5cGU6IHBhcmFtLmNvbnRlbnRUeXBlID8gcGFyYW0uY29udGVudFR5cGUgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5mb3JtRGF0YVtwYXJhbS5uYW1lXSA9IGF0dGFjaG1lbnRcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXEucG9zdERhdGEudGV4dCkge1xuICAgICAgb3B0aW9ucy5ib2R5ID0gcmVxLnBvc3REYXRhLnRleHRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5leHBvcnRzLkhhciA9IEhhclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/har.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/hawk.js":
/*!******************************************!*\
  !*** ./node_modules/request/lib/hawk.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\n\nfunction randomString (size) {\n  var bits = (size + 1) * 6\n  var buffer = crypto.randomBytes(Math.ceil(bits / 8))\n  var string = buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\n  return string.slice(0, size)\n}\n\nfunction calculatePayloadHash (payload, algorithm, contentType) {\n  var hash = crypto.createHash(algorithm)\n  hash.update('hawk.1.payload\\n')\n  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\\n')\n  hash.update(payload || '')\n  hash.update('\\n')\n  return hash.digest('base64')\n}\n\nexports.calculateMac = function (credentials, opts) {\n  var normalized = 'hawk.1.header\\n' +\n    opts.ts + '\\n' +\n    opts.nonce + '\\n' +\n    (opts.method || '').toUpperCase() + '\\n' +\n    opts.resource + '\\n' +\n    opts.host.toLowerCase() + '\\n' +\n    opts.port + '\\n' +\n    (opts.hash || '') + '\\n'\n\n  if (opts.ext) {\n    normalized = normalized + opts.ext.replace('\\\\', '\\\\\\\\').replace('\\n', '\\\\n')\n  }\n\n  normalized = normalized + '\\n'\n\n  if (opts.app) {\n    normalized = normalized + opts.app + '\\n' + (opts.dlg || '') + '\\n'\n  }\n\n  var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized)\n  var digest = hmac.digest('base64')\n  return digest\n}\n\nexports.header = function (uri, method, opts) {\n  var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000)\n  var credentials = opts.credentials\n  if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {\n    return ''\n  }\n\n  if (['sha1', 'sha256'].indexOf(credentials.algorithm) === -1) {\n    return ''\n  }\n\n  var artifacts = {\n    ts: timestamp,\n    nonce: opts.nonce || randomString(6),\n    method: method,\n    resource: uri.pathname + (uri.search || ''),\n    host: uri.hostname,\n    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),\n    hash: opts.hash,\n    ext: opts.ext,\n    app: opts.app,\n    dlg: opts.dlg\n  }\n\n  if (!artifacts.hash && (opts.payload || opts.payload === '')) {\n    artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType)\n  }\n\n  var mac = exports.calculateMac(credentials, artifacts)\n\n  var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== ''\n  var header = 'Hawk id=\"' + credentials.id +\n    '\", ts=\"' + artifacts.ts +\n    '\", nonce=\"' + artifacts.nonce +\n    (artifacts.hash ? '\", hash=\"' + artifacts.hash : '') +\n    (hasExt ? '\", ext=\"' + artifacts.ext.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') : '') +\n    '\", mac=\"' + mac + '\"'\n\n  if (artifacts.app) {\n    header = header + ', app=\"' + artifacts.app + (artifacts.dlg ? '\", dlg=\"' + artifacts.dlg : '') + '\"'\n  }\n\n  return header\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGF3ay5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJGaWxlc1xcZ2lmX2FwcFxcZ2lmX2FwcFxcbm9kZV9tb2R1bGVzXFxyZXF1ZXN0XFxsaWJcXGhhd2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuXG5mdW5jdGlvbiByYW5kb21TdHJpbmcgKHNpemUpIHtcbiAgdmFyIGJpdHMgPSAoc2l6ZSArIDEpICogNlxuICB2YXIgYnVmZmVyID0gY3J5cHRvLnJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpXG4gIHZhciBzdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0vZywgJycpXG4gIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGF5bG9hZEhhc2ggKHBheWxvYWQsIGFsZ29yaXRobSwgY29udGVudFR5cGUpIHtcbiAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pXG4gIGhhc2gudXBkYXRlKCdoYXdrLjEucGF5bG9hZFxcbicpXG4gIGhhc2gudXBkYXRlKChjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCkgOiAnJykgKyAnXFxuJylcbiAgaGFzaC51cGRhdGUocGF5bG9hZCB8fCAnJylcbiAgaGFzaC51cGRhdGUoJ1xcbicpXG4gIHJldHVybiBoYXNoLmRpZ2VzdCgnYmFzZTY0Jylcbn1cblxuZXhwb3J0cy5jYWxjdWxhdGVNYWMgPSBmdW5jdGlvbiAoY3JlZGVudGlhbHMsIG9wdHMpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSAnaGF3ay4xLmhlYWRlclxcbicgK1xuICAgIG9wdHMudHMgKyAnXFxuJyArXG4gICAgb3B0cy5ub25jZSArICdcXG4nICtcbiAgICAob3B0cy5tZXRob2QgfHwgJycpLnRvVXBwZXJDYXNlKCkgKyAnXFxuJyArXG4gICAgb3B0cy5yZXNvdXJjZSArICdcXG4nICtcbiAgICBvcHRzLmhvc3QudG9Mb3dlckNhc2UoKSArICdcXG4nICtcbiAgICBvcHRzLnBvcnQgKyAnXFxuJyArXG4gICAgKG9wdHMuaGFzaCB8fCAnJykgKyAnXFxuJ1xuXG4gIGlmIChvcHRzLmV4dCkge1xuICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkICsgb3B0cy5leHQucmVwbGFjZSgnXFxcXCcsICdcXFxcXFxcXCcpLnJlcGxhY2UoJ1xcbicsICdcXFxcbicpXG4gIH1cblxuICBub3JtYWxpemVkID0gbm9ybWFsaXplZCArICdcXG4nXG5cbiAgaWYgKG9wdHMuYXBwKSB7XG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgKyBvcHRzLmFwcCArICdcXG4nICsgKG9wdHMuZGxnIHx8ICcnKSArICdcXG4nXG4gIH1cblxuICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgY3JlZGVudGlhbHMua2V5KS51cGRhdGUobm9ybWFsaXplZClcbiAgdmFyIGRpZ2VzdCA9IGhtYWMuZGlnZXN0KCdiYXNlNjQnKVxuICByZXR1cm4gZGlnZXN0XG59XG5cbmV4cG9ydHMuaGVhZGVyID0gZnVuY3Rpb24gKHVyaSwgbWV0aG9kLCBvcHRzKSB7XG4gIHZhciB0aW1lc3RhbXAgPSBvcHRzLnRpbWVzdGFtcCB8fCBNYXRoLmZsb29yKChEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKSkgLyAxMDAwKVxuICB2YXIgY3JlZGVudGlhbHMgPSBvcHRzLmNyZWRlbnRpYWxzXG4gIGlmICghY3JlZGVudGlhbHMgfHwgIWNyZWRlbnRpYWxzLmlkIHx8ICFjcmVkZW50aWFscy5rZXkgfHwgIWNyZWRlbnRpYWxzLmFsZ29yaXRobSkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKFsnc2hhMScsICdzaGEyNTYnXS5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICB2YXIgYXJ0aWZhY3RzID0ge1xuICAgIHRzOiB0aW1lc3RhbXAsXG4gICAgbm9uY2U6IG9wdHMubm9uY2UgfHwgcmFuZG9tU3RyaW5nKDYpLFxuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIHJlc291cmNlOiB1cmkucGF0aG5hbWUgKyAodXJpLnNlYXJjaCB8fCAnJyksXG4gICAgaG9zdDogdXJpLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09ICdodHRwOicgPyA4MCA6IDQ0MyksXG4gICAgaGFzaDogb3B0cy5oYXNoLFxuICAgIGV4dDogb3B0cy5leHQsXG4gICAgYXBwOiBvcHRzLmFwcCxcbiAgICBkbGc6IG9wdHMuZGxnXG4gIH1cblxuICBpZiAoIWFydGlmYWN0cy5oYXNoICYmIChvcHRzLnBheWxvYWQgfHwgb3B0cy5wYXlsb2FkID09PSAnJykpIHtcbiAgICBhcnRpZmFjdHMuaGFzaCA9IGNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdHMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBvcHRzLmNvbnRlbnRUeXBlKVxuICB9XG5cbiAgdmFyIG1hYyA9IGV4cG9ydHMuY2FsY3VsYXRlTWFjKGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpXG5cbiAgdmFyIGhhc0V4dCA9IGFydGlmYWN0cy5leHQgIT09IG51bGwgJiYgYXJ0aWZhY3RzLmV4dCAhPT0gdW5kZWZpbmVkICYmIGFydGlmYWN0cy5leHQgIT09ICcnXG4gIHZhciBoZWFkZXIgPSAnSGF3ayBpZD1cIicgKyBjcmVkZW50aWFscy5pZCArXG4gICAgJ1wiLCB0cz1cIicgKyBhcnRpZmFjdHMudHMgK1xuICAgICdcIiwgbm9uY2U9XCInICsgYXJ0aWZhY3RzLm5vbmNlICtcbiAgICAoYXJ0aWZhY3RzLmhhc2ggPyAnXCIsIGhhc2g9XCInICsgYXJ0aWZhY3RzLmhhc2ggOiAnJykgK1xuICAgIChoYXNFeHQgPyAnXCIsIGV4dD1cIicgKyBhcnRpZmFjdHMuZXh0LnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIDogJycpICtcbiAgICAnXCIsIG1hYz1cIicgKyBtYWMgKyAnXCInXG5cbiAgaWYgKGFydGlmYWN0cy5hcHApIHtcbiAgICBoZWFkZXIgPSBoZWFkZXIgKyAnLCBhcHA9XCInICsgYXJ0aWZhY3RzLmFwcCArIChhcnRpZmFjdHMuZGxnID8gJ1wiLCBkbGc9XCInICsgYXJ0aWZhY3RzLmRsZyA6ICcnKSArICdcIidcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/hawk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/helpers.js":
/*!*********************************************!*\
  !*** ./node_modules/request/lib/helpers.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar jsonSafeStringify = __webpack_require__(/*! json-stringify-safe */ \"(ssr)/./node_modules/json-stringify-safe/stringify.js\")\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n\nvar defer = typeof setImmediate === 'undefined'\n  ? process.nextTick\n  : setImmediate\n\nfunction paramsHaveRequestBody (params) {\n  return (\n    params.body ||\n    params.requestBodyStream ||\n    (params.json && typeof params.json !== 'boolean') ||\n    params.multipart\n  )\n}\n\nfunction safeStringify (obj, replacer) {\n  var ret\n  try {\n    ret = JSON.stringify(obj, replacer)\n  } catch (e) {\n    ret = jsonSafeStringify(obj, replacer)\n  }\n  return ret\n}\n\nfunction md5 (str) {\n  return crypto.createHash('md5').update(str).digest('hex')\n}\n\nfunction isReadStream (rs) {\n  return rs.readable && rs.path && rs.mode\n}\n\nfunction toBase64 (str) {\n  return Buffer.from(str || '', 'utf8').toString('base64')\n}\n\nfunction copy (obj) {\n  var o = {}\n  Object.keys(obj).forEach(function (i) {\n    o[i] = obj[i]\n  })\n  return o\n}\n\nfunction version () {\n  var numbers = process.version.replace('v', '').split('.')\n  return {\n    major: parseInt(numbers[0], 10),\n    minor: parseInt(numbers[1], 10),\n    patch: parseInt(numbers[2], 10)\n  }\n}\n\nexports.paramsHaveRequestBody = paramsHaveRequestBody\nexports.safeStringify = safeStringify\nexports.md5 = md5\nexports.isReadStream = isReadStream\nexports.toBase64 = toBase64\nexports.copy = copy\nexports.version = version\nexports.defer = defer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDckQsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsNEZBQTZCOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osZUFBZTtBQUNmLGFBQWEiLCJzb3VyY2VzIjpbIkM6XFxVc2VyRmlsZXNcXGdpZl9hcHBcXGdpZl9hcHBcXG5vZGVfbW9kdWxlc1xccmVxdWVzdFxcbGliXFxoZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIganNvblNhZmVTdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uLXN0cmluZ2lmeS1zYWZlJylcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBkZWZlciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICd1bmRlZmluZWQnXG4gID8gcHJvY2Vzcy5uZXh0VGlja1xuICA6IHNldEltbWVkaWF0ZVxuXG5mdW5jdGlvbiBwYXJhbXNIYXZlUmVxdWVzdEJvZHkgKHBhcmFtcykge1xuICByZXR1cm4gKFxuICAgIHBhcmFtcy5ib2R5IHx8XG4gICAgcGFyYW1zLnJlcXVlc3RCb2R5U3RyZWFtIHx8XG4gICAgKHBhcmFtcy5qc29uICYmIHR5cGVvZiBwYXJhbXMuanNvbiAhPT0gJ2Jvb2xlYW4nKSB8fFxuICAgIHBhcmFtcy5tdWx0aXBhcnRcbiAgKVxufVxuXG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyKSB7XG4gIHZhciByZXRcbiAgdHJ5IHtcbiAgICByZXQgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0ID0ganNvblNhZmVTdHJpbmdpZnkob2JqLCByZXBsYWNlcilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIG1kNSAoc3RyKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHN0cikuZGlnZXN0KCdoZXgnKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRTdHJlYW0gKHJzKSB7XG4gIHJldHVybiBycy5yZWFkYWJsZSAmJiBycy5wYXRoICYmIHJzLm1vZGVcbn1cblxuZnVuY3Rpb24gdG9CYXNlNjQgKHN0cikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyIHx8ICcnLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjb3B5IChvYmopIHtcbiAgdmFyIG8gPSB7fVxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBvW2ldID0gb2JqW2ldXG4gIH0pXG4gIHJldHVybiBvXG59XG5cbmZ1bmN0aW9uIHZlcnNpb24gKCkge1xuICB2YXIgbnVtYmVycyA9IHByb2Nlc3MudmVyc2lvbi5yZXBsYWNlKCd2JywgJycpLnNwbGl0KCcuJylcbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogcGFyc2VJbnQobnVtYmVyc1swXSwgMTApLFxuICAgIG1pbm9yOiBwYXJzZUludChudW1iZXJzWzFdLCAxMCksXG4gICAgcGF0Y2g6IHBhcnNlSW50KG51bWJlcnNbMl0sIDEwKVxuICB9XG59XG5cbmV4cG9ydHMucGFyYW1zSGF2ZVJlcXVlc3RCb2R5ID0gcGFyYW1zSGF2ZVJlcXVlc3RCb2R5XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5XG5leHBvcnRzLm1kNSA9IG1kNVxuZXhwb3J0cy5pc1JlYWRTdHJlYW0gPSBpc1JlYWRTdHJlYW1cbmV4cG9ydHMudG9CYXNlNjQgPSB0b0Jhc2U2NFxuZXhwb3J0cy5jb3B5ID0gY29weVxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvblxuZXhwb3J0cy5kZWZlciA9IGRlZmVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/multipart.js":
/*!***********************************************!*\
  !*** ./node_modules/request/lib/multipart.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar uuid = __webpack_require__(/*! uuid/v4 */ \"(ssr)/./node_modules/uuid/v4.js\")\nvar CombinedStream = __webpack_require__(/*! combined-stream */ \"(ssr)/./node_modules/combined-stream/lib/combined_stream.js\")\nvar isstream = __webpack_require__(/*! isstream */ \"(ssr)/./node_modules/isstream/isstream.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n\nfunction Multipart (request) {\n  this.request = request\n  this.boundary = uuid()\n  this.chunked = false\n  this.body = null\n}\n\nMultipart.prototype.isChunked = function (options) {\n  var self = this\n  var chunked = false\n  var parts = options.data || options\n\n  if (!parts.forEach) {\n    self.request.emit('error', new Error('Argument error, options.multipart.'))\n  }\n\n  if (options.chunked !== undefined) {\n    chunked = options.chunked\n  }\n\n  if (self.request.getHeader('transfer-encoding') === 'chunked') {\n    chunked = true\n  }\n\n  if (!chunked) {\n    parts.forEach(function (part) {\n      if (typeof part.body === 'undefined') {\n        self.request.emit('error', new Error('Body attribute missing in multipart.'))\n      }\n      if (isstream(part.body)) {\n        chunked = true\n      }\n    })\n  }\n\n  return chunked\n}\n\nMultipart.prototype.setHeaders = function (chunked) {\n  var self = this\n\n  if (chunked && !self.request.hasHeader('transfer-encoding')) {\n    self.request.setHeader('transfer-encoding', 'chunked')\n  }\n\n  var header = self.request.getHeader('content-type')\n\n  if (!header || header.indexOf('multipart') === -1) {\n    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)\n  } else {\n    if (header.indexOf('boundary') !== -1) {\n      self.boundary = header.replace(/.*boundary=([^\\s;]+).*/, '$1')\n    } else {\n      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)\n    }\n  }\n}\n\nMultipart.prototype.build = function (parts, chunked) {\n  var self = this\n  var body = chunked ? new CombinedStream() : []\n\n  function add (part) {\n    if (typeof part === 'number') {\n      part = part.toString()\n    }\n    return chunked ? body.append(part) : body.push(Buffer.from(part))\n  }\n\n  if (self.request.preambleCRLF) {\n    add('\\r\\n')\n  }\n\n  parts.forEach(function (part) {\n    var preamble = '--' + self.boundary + '\\r\\n'\n    Object.keys(part).forEach(function (key) {\n      if (key === 'body') { return }\n      preamble += key + ': ' + part[key] + '\\r\\n'\n    })\n    preamble += '\\r\\n'\n    add(preamble)\n    add(part.body)\n    add('\\r\\n')\n  })\n  add('--' + self.boundary + '--')\n\n  if (self.request.postambleCRLF) {\n    add('\\r\\n')\n  }\n\n  return body\n}\n\nMultipart.prototype.onRequest = function (options) {\n  var self = this\n\n  var chunked = self.isChunked(options)\n  var parts = options.data || options\n\n  self.setHeaders(chunked)\n  self.chunked = chunked\n  self.body = self.build(parts, chunked)\n}\n\nexports.Multipart = Multipart\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvbXVsdGlwYXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyxnREFBUztBQUM1QixxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLDJEQUFVO0FBQ2pDLGFBQWEsNEZBQTZCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBLHVEQUF1RDtBQUN2RCxNQUFNO0FBQ04seURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJGaWxlc1xcZ2lmX2FwcFxcZ2lmX2FwcFxcbm9kZV9tb2R1bGVzXFxyZXF1ZXN0XFxsaWJcXG11bHRpcGFydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3Y0JylcbnZhciBDb21iaW5lZFN0cmVhbSA9IHJlcXVpcmUoJ2NvbWJpbmVkLXN0cmVhbScpXG52YXIgaXNzdHJlYW0gPSByZXF1aXJlKCdpc3N0cmVhbScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gTXVsdGlwYXJ0IChyZXF1ZXN0KSB7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgdGhpcy5ib3VuZGFyeSA9IHV1aWQoKVxuICB0aGlzLmNodW5rZWQgPSBmYWxzZVxuICB0aGlzLmJvZHkgPSBudWxsXG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUuaXNDaHVua2VkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBjaHVua2VkID0gZmFsc2VcbiAgdmFyIHBhcnRzID0gb3B0aW9ucy5kYXRhIHx8IG9wdGlvbnNcblxuICBpZiAoIXBhcnRzLmZvckVhY2gpIHtcbiAgICBzZWxmLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0FyZ3VtZW50IGVycm9yLCBvcHRpb25zLm11bHRpcGFydC4nKSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmNodW5rZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNodW5rZWQgPSBvcHRpb25zLmNodW5rZWRcbiAgfVxuXG4gIGlmIChzZWxmLnJlcXVlc3QuZ2V0SGVhZGVyKCd0cmFuc2Zlci1lbmNvZGluZycpID09PSAnY2h1bmtlZCcpIHtcbiAgICBjaHVua2VkID0gdHJ1ZVxuICB9XG5cbiAgaWYgKCFjaHVua2VkKSB7XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0LmJvZHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQm9keSBhdHRyaWJ1dGUgbWlzc2luZyBpbiBtdWx0aXBhcnQuJykpXG4gICAgICB9XG4gICAgICBpZiAoaXNzdHJlYW0ocGFydC5ib2R5KSkge1xuICAgICAgICBjaHVua2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gY2h1bmtlZFxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLnNldEhlYWRlcnMgPSBmdW5jdGlvbiAoY2h1bmtlZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoY2h1bmtlZCAmJiAhc2VsZi5yZXF1ZXN0Lmhhc0hlYWRlcigndHJhbnNmZXItZW5jb2RpbmcnKSkge1xuICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJywgJ2NodW5rZWQnKVxuICB9XG5cbiAgdmFyIGhlYWRlciA9IHNlbGYucmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG5cbiAgaWYgKCFoZWFkZXIgfHwgaGVhZGVyLmluZGV4T2YoJ211bHRpcGFydCcpID09PSAtMSkge1xuICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdtdWx0aXBhcnQvcmVsYXRlZDsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnkpXG4gIH0gZWxzZSB7XG4gICAgaWYgKGhlYWRlci5pbmRleE9mKCdib3VuZGFyeScpICE9PSAtMSkge1xuICAgICAgc2VsZi5ib3VuZGFyeSA9IGhlYWRlci5yZXBsYWNlKC8uKmJvdW5kYXJ5PShbXlxccztdKykuKi8sICckMScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGhlYWRlciArICc7IGJvdW5kYXJ5PScgKyBzZWxmLmJvdW5kYXJ5KVxuICAgIH1cbiAgfVxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKHBhcnRzLCBjaHVua2VkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYm9keSA9IGNodW5rZWQgPyBuZXcgQ29tYmluZWRTdHJlYW0oKSA6IFtdXG5cbiAgZnVuY3Rpb24gYWRkIChwYXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgcGFydCA9IHBhcnQudG9TdHJpbmcoKVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmtlZCA/IGJvZHkuYXBwZW5kKHBhcnQpIDogYm9keS5wdXNoKEJ1ZmZlci5mcm9tKHBhcnQpKVxuICB9XG5cbiAgaWYgKHNlbGYucmVxdWVzdC5wcmVhbWJsZUNSTEYpIHtcbiAgICBhZGQoJ1xcclxcbicpXG4gIH1cblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdmFyIHByZWFtYmxlID0gJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnXFxyXFxuJ1xuICAgIE9iamVjdC5rZXlzKHBhcnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2JvZHknKSB7IHJldHVybiB9XG4gICAgICBwcmVhbWJsZSArPSBrZXkgKyAnOiAnICsgcGFydFtrZXldICsgJ1xcclxcbidcbiAgICB9KVxuICAgIHByZWFtYmxlICs9ICdcXHJcXG4nXG4gICAgYWRkKHByZWFtYmxlKVxuICAgIGFkZChwYXJ0LmJvZHkpXG4gICAgYWRkKCdcXHJcXG4nKVxuICB9KVxuICBhZGQoJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnLS0nKVxuXG4gIGlmIChzZWxmLnJlcXVlc3QucG9zdGFtYmxlQ1JMRikge1xuICAgIGFkZCgnXFxyXFxuJylcbiAgfVxuXG4gIHJldHVybiBib2R5XG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGNodW5rZWQgPSBzZWxmLmlzQ2h1bmtlZChvcHRpb25zKVxuICB2YXIgcGFydHMgPSBvcHRpb25zLmRhdGEgfHwgb3B0aW9uc1xuXG4gIHNlbGYuc2V0SGVhZGVycyhjaHVua2VkKVxuICBzZWxmLmNodW5rZWQgPSBjaHVua2VkXG4gIHNlbGYuYm9keSA9IHNlbGYuYnVpbGQocGFydHMsIGNodW5rZWQpXG59XG5cbmV4cG9ydHMuTXVsdGlwYXJ0ID0gTXVsdGlwYXJ0XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/multipart.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/oauth.js":
/*!*******************************************!*\
  !*** ./node_modules/request/lib/oauth.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar url = __webpack_require__(/*! url */ \"url\")\nvar qs = __webpack_require__(/*! qs */ \"(ssr)/./node_modules/qs/lib/index.js\")\nvar caseless = __webpack_require__(/*! caseless */ \"(ssr)/./node_modules/caseless/index.js\")\nvar uuid = __webpack_require__(/*! uuid/v4 */ \"(ssr)/./node_modules/uuid/v4.js\")\nvar oauth = __webpack_require__(/*! oauth-sign */ \"(ssr)/./node_modules/oauth-sign/index.js\")\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n\nfunction OAuth (request) {\n  this.request = request\n  this.params = null\n}\n\nOAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {\n  var oa = {}\n  for (var i in _oauth) {\n    oa['oauth_' + i] = _oauth[i]\n  }\n  if (!oa.oauth_version) {\n    oa.oauth_version = '1.0'\n  }\n  if (!oa.oauth_timestamp) {\n    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()\n  }\n  if (!oa.oauth_nonce) {\n    oa.oauth_nonce = uuid().replace(/-/g, '')\n  }\n  if (!oa.oauth_signature_method) {\n    oa.oauth_signature_method = 'HMAC-SHA1'\n  }\n\n  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key // eslint-disable-line camelcase\n  delete oa.oauth_consumer_secret\n  delete oa.oauth_private_key\n\n  var token_secret = oa.oauth_token_secret // eslint-disable-line camelcase\n  delete oa.oauth_token_secret\n\n  var realm = oa.oauth_realm\n  delete oa.oauth_realm\n  delete oa.oauth_transport_method\n\n  var baseurl = uri.protocol + '//' + uri.host + uri.pathname\n  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))\n\n  oa.oauth_signature = oauth.sign(\n    oa.oauth_signature_method,\n    method,\n    baseurl,\n    params,\n    consumer_secret_or_private_key, // eslint-disable-line camelcase\n    token_secret // eslint-disable-line camelcase\n  )\n\n  if (realm) {\n    oa.realm = realm\n  }\n\n  return oa\n}\n\nOAuth.prototype.buildBodyHash = function (_oauth, body) {\n  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {\n    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +\n      ' signature_method not supported with body_hash signing.'))\n  }\n\n  var shasum = crypto.createHash('sha1')\n  shasum.update(body || '')\n  var sha1 = shasum.digest('hex')\n\n  return Buffer.from(sha1, 'hex').toString('base64')\n}\n\nOAuth.prototype.concatParams = function (oa, sep, wrap) {\n  wrap = wrap || ''\n\n  var params = Object.keys(oa).filter(function (i) {\n    return i !== 'realm' && i !== 'oauth_signature'\n  }).sort()\n\n  if (oa.realm) {\n    params.splice(0, 0, 'realm')\n  }\n  params.push('oauth_signature')\n\n  return params.map(function (i) {\n    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap\n  }).join(sep)\n}\n\nOAuth.prototype.onRequest = function (_oauth) {\n  var self = this\n  self.params = _oauth\n\n  var uri = self.request.uri || {}\n  var method = self.request.method || ''\n  var headers = caseless(self.request.headers)\n  var body = self.request.body || ''\n  var qsLib = self.request.qsLib || qs\n\n  var form\n  var query\n  var contentType = headers.get('content-type') || ''\n  var formContentType = 'application/x-www-form-urlencoded'\n  var transport = _oauth.transport_method || 'header'\n\n  if (contentType.slice(0, formContentType.length) === formContentType) {\n    contentType = formContentType\n    form = body\n  }\n  if (uri.query) {\n    query = uri.query\n  }\n  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {\n    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +\n      'and content-type ' + formContentType))\n  }\n\n  if (!form && typeof _oauth.body_hash === 'boolean') {\n    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())\n  }\n\n  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)\n\n  switch (transport) {\n    case 'header':\n      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '\"'))\n      break\n\n    case 'query':\n      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')\n      self.request.uri = url.parse(href)\n      self.request.path = self.request.uri.path\n      break\n\n    case 'body':\n      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')\n      break\n\n    default:\n      self.request.emit('error', new Error('oauth: transport_method invalid'))\n  }\n}\n\nexports.OAuth = OAuth\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvb2F1dGguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFNBQVMsbUJBQU8sQ0FBQyxnREFBSTtBQUNyQixlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLGdEQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyw0REFBWTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsYUFBYSw0RkFBNkI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEiLCJzb3VyY2VzIjpbIkM6XFxVc2VyRmlsZXNcXGdpZl9hcHBcXGdpZl9hcHBcXG5vZGVfbW9kdWxlc1xccmVxdWVzdFxcbGliXFxvYXV0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgcXMgPSByZXF1aXJlKCdxcycpXG52YXIgY2FzZWxlc3MgPSByZXF1aXJlKCdjYXNlbGVzcycpXG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjQnKVxudmFyIG9hdXRoID0gcmVxdWlyZSgnb2F1dGgtc2lnbicpXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBPQXV0aCAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMucGFyYW1zID0gbnVsbFxufVxuXG5PQXV0aC5wcm90b3R5cGUuYnVpbGRQYXJhbXMgPSBmdW5jdGlvbiAoX29hdXRoLCB1cmksIG1ldGhvZCwgcXVlcnksIGZvcm0sIHFzTGliKSB7XG4gIHZhciBvYSA9IHt9XG4gIGZvciAodmFyIGkgaW4gX29hdXRoKSB7XG4gICAgb2FbJ29hdXRoXycgKyBpXSA9IF9vYXV0aFtpXVxuICB9XG4gIGlmICghb2Eub2F1dGhfdmVyc2lvbikge1xuICAgIG9hLm9hdXRoX3ZlcnNpb24gPSAnMS4wJ1xuICB9XG4gIGlmICghb2Eub2F1dGhfdGltZXN0YW1wKSB7XG4gICAgb2Eub2F1dGhfdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoKVxuICB9XG4gIGlmICghb2Eub2F1dGhfbm9uY2UpIHtcbiAgICBvYS5vYXV0aF9ub25jZSA9IHV1aWQoKS5yZXBsYWNlKC8tL2csICcnKVxuICB9XG4gIGlmICghb2Eub2F1dGhfc2lnbmF0dXJlX21ldGhvZCkge1xuICAgIG9hLm9hdXRoX3NpZ25hdHVyZV9tZXRob2QgPSAnSE1BQy1TSEExJ1xuICB9XG5cbiAgdmFyIGNvbnN1bWVyX3NlY3JldF9vcl9wcml2YXRlX2tleSA9IG9hLm9hdXRoX2NvbnN1bWVyX3NlY3JldCB8fCBvYS5vYXV0aF9wcml2YXRlX2tleSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICBkZWxldGUgb2Eub2F1dGhfY29uc3VtZXJfc2VjcmV0XG4gIGRlbGV0ZSBvYS5vYXV0aF9wcml2YXRlX2tleVxuXG4gIHZhciB0b2tlbl9zZWNyZXQgPSBvYS5vYXV0aF90b2tlbl9zZWNyZXQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgZGVsZXRlIG9hLm9hdXRoX3Rva2VuX3NlY3JldFxuXG4gIHZhciByZWFsbSA9IG9hLm9hdXRoX3JlYWxtXG4gIGRlbGV0ZSBvYS5vYXV0aF9yZWFsbVxuICBkZWxldGUgb2Eub2F1dGhfdHJhbnNwb3J0X21ldGhvZFxuXG4gIHZhciBiYXNldXJsID0gdXJpLnByb3RvY29sICsgJy8vJyArIHVyaS5ob3N0ICsgdXJpLnBhdGhuYW1lXG4gIHZhciBwYXJhbXMgPSBxc0xpYi5wYXJzZShbXS5jb25jYXQocXVlcnksIGZvcm0sIHFzTGliLnN0cmluZ2lmeShvYSkpLmpvaW4oJyYnKSlcblxuICBvYS5vYXV0aF9zaWduYXR1cmUgPSBvYXV0aC5zaWduKFxuICAgIG9hLm9hdXRoX3NpZ25hdHVyZV9tZXRob2QsXG4gICAgbWV0aG9kLFxuICAgIGJhc2V1cmwsXG4gICAgcGFyYW1zLFxuICAgIGNvbnN1bWVyX3NlY3JldF9vcl9wcml2YXRlX2tleSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICB0b2tlbl9zZWNyZXQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgKVxuXG4gIGlmIChyZWFsbSkge1xuICAgIG9hLnJlYWxtID0gcmVhbG1cbiAgfVxuXG4gIHJldHVybiBvYVxufVxuXG5PQXV0aC5wcm90b3R5cGUuYnVpbGRCb2R5SGFzaCA9IGZ1bmN0aW9uIChfb2F1dGgsIGJvZHkpIHtcbiAgaWYgKFsnSE1BQy1TSEExJywgJ1JTQS1TSEExJ10uaW5kZXhPZihfb2F1dGguc2lnbmF0dXJlX21ldGhvZCB8fCAnSE1BQy1TSEExJykgPCAwKSB7XG4gICAgdGhpcy5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvYXV0aDogJyArIF9vYXV0aC5zaWduYXR1cmVfbWV0aG9kICtcbiAgICAgICcgc2lnbmF0dXJlX21ldGhvZCBub3Qgc3VwcG9ydGVkIHdpdGggYm9keV9oYXNoIHNpZ25pbmcuJykpXG4gIH1cblxuICB2YXIgc2hhc3VtID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICBzaGFzdW0udXBkYXRlKGJvZHkgfHwgJycpXG4gIHZhciBzaGExID0gc2hhc3VtLmRpZ2VzdCgnaGV4JylcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2hhMSwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5PQXV0aC5wcm90b3R5cGUuY29uY2F0UGFyYW1zID0gZnVuY3Rpb24gKG9hLCBzZXAsIHdyYXApIHtcbiAgd3JhcCA9IHdyYXAgfHwgJydcblxuICB2YXIgcGFyYW1zID0gT2JqZWN0LmtleXMob2EpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICE9PSAncmVhbG0nICYmIGkgIT09ICdvYXV0aF9zaWduYXR1cmUnXG4gIH0pLnNvcnQoKVxuXG4gIGlmIChvYS5yZWFsbSkge1xuICAgIHBhcmFtcy5zcGxpY2UoMCwgMCwgJ3JlYWxtJylcbiAgfVxuICBwYXJhbXMucHVzaCgnb2F1dGhfc2lnbmF0dXJlJylcblxuICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICsgJz0nICsgd3JhcCArIG9hdXRoLnJmYzM5ODYob2FbaV0pICsgd3JhcFxuICB9KS5qb2luKHNlcClcbn1cblxuT0F1dGgucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYucGFyYW1zID0gX29hdXRoXG5cbiAgdmFyIHVyaSA9IHNlbGYucmVxdWVzdC51cmkgfHwge31cbiAgdmFyIG1ldGhvZCA9IHNlbGYucmVxdWVzdC5tZXRob2QgfHwgJydcbiAgdmFyIGhlYWRlcnMgPSBjYXNlbGVzcyhzZWxmLnJlcXVlc3QuaGVhZGVycylcbiAgdmFyIGJvZHkgPSBzZWxmLnJlcXVlc3QuYm9keSB8fCAnJ1xuICB2YXIgcXNMaWIgPSBzZWxmLnJlcXVlc3QucXNMaWIgfHwgcXNcblxuICB2YXIgZm9ybVxuICB2YXIgcXVlcnlcbiAgdmFyIGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnXG4gIHZhciBmb3JtQ29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICB2YXIgdHJhbnNwb3J0ID0gX29hdXRoLnRyYW5zcG9ydF9tZXRob2QgfHwgJ2hlYWRlcidcblxuICBpZiAoY29udGVudFR5cGUuc2xpY2UoMCwgZm9ybUNvbnRlbnRUeXBlLmxlbmd0aCkgPT09IGZvcm1Db250ZW50VHlwZSkge1xuICAgIGNvbnRlbnRUeXBlID0gZm9ybUNvbnRlbnRUeXBlXG4gICAgZm9ybSA9IGJvZHlcbiAgfVxuICBpZiAodXJpLnF1ZXJ5KSB7XG4gICAgcXVlcnkgPSB1cmkucXVlcnlcbiAgfVxuICBpZiAodHJhbnNwb3J0ID09PSAnYm9keScgJiYgKG1ldGhvZCAhPT0gJ1BPU1QnIHx8IGNvbnRlbnRUeXBlICE9PSBmb3JtQ29udGVudFR5cGUpKSB7XG4gICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvYXV0aDogdHJhbnNwb3J0X21ldGhvZCBvZiBib2R5IHJlcXVpcmVzIFBPU1QgJyArXG4gICAgICAnYW5kIGNvbnRlbnQtdHlwZSAnICsgZm9ybUNvbnRlbnRUeXBlKSlcbiAgfVxuXG4gIGlmICghZm9ybSAmJiB0eXBlb2YgX29hdXRoLmJvZHlfaGFzaCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgX29hdXRoLmJvZHlfaGFzaCA9IHNlbGYuYnVpbGRCb2R5SGFzaChfb2F1dGgsIHNlbGYucmVxdWVzdC5ib2R5LnRvU3RyaW5nKCkpXG4gIH1cblxuICB2YXIgb2EgPSBzZWxmLmJ1aWxkUGFyYW1zKF9vYXV0aCwgdXJpLCBtZXRob2QsIHF1ZXJ5LCBmb3JtLCBxc0xpYilcblxuICBzd2l0Y2ggKHRyYW5zcG9ydCkge1xuICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBzZWxmLnJlcXVlc3Quc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ09BdXRoICcgKyBzZWxmLmNvbmNhdFBhcmFtcyhvYSwgJywnLCAnXCInKSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICB2YXIgaHJlZiA9IHNlbGYucmVxdWVzdC51cmkuaHJlZiArPSAocXVlcnkgPyAnJicgOiAnPycpICsgc2VsZi5jb25jYXRQYXJhbXMob2EsICcmJylcbiAgICAgIHNlbGYucmVxdWVzdC51cmkgPSB1cmwucGFyc2UoaHJlZilcbiAgICAgIHNlbGYucmVxdWVzdC5wYXRoID0gc2VsZi5yZXF1ZXN0LnVyaS5wYXRoXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnYm9keSc6XG4gICAgICBzZWxmLnJlcXVlc3QuYm9keSA9IChmb3JtID8gZm9ybSArICcmJyA6ICcnKSArIHNlbGYuY29uY2F0UGFyYW1zKG9hLCAnJicpXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb2F1dGg6IHRyYW5zcG9ydF9tZXRob2QgaW52YWxpZCcpKVxuICB9XG59XG5cbmV4cG9ydHMuT0F1dGggPSBPQXV0aFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/oauth.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/querystring.js":
/*!*************************************************!*\
  !*** ./node_modules/request/lib/querystring.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar qs = __webpack_require__(/*! qs */ \"(ssr)/./node_modules/qs/lib/index.js\")\nvar querystring = __webpack_require__(/*! querystring */ \"querystring\")\n\nfunction Querystring (request) {\n  this.request = request\n  this.lib = null\n  this.useQuerystring = null\n  this.parseOptions = null\n  this.stringifyOptions = null\n}\n\nQuerystring.prototype.init = function (options) {\n  if (this.lib) { return }\n\n  this.useQuerystring = options.useQuerystring\n  this.lib = (this.useQuerystring ? querystring : qs)\n\n  this.parseOptions = options.qsParseOptions || {}\n  this.stringifyOptions = options.qsStringifyOptions || {}\n}\n\nQuerystring.prototype.stringify = function (obj) {\n  return (this.useQuerystring)\n    ? this.rfc3986(this.lib.stringify(obj,\n      this.stringifyOptions.sep || null,\n      this.stringifyOptions.eq || null,\n      this.stringifyOptions))\n    : this.lib.stringify(obj, this.stringifyOptions)\n}\n\nQuerystring.prototype.parse = function (str) {\n  return (this.useQuerystring)\n    ? this.lib.parse(str,\n      this.parseOptions.sep || null,\n      this.parseOptions.eq || null,\n      this.parseOptions)\n    : this.lib.parse(str, this.parseOptions)\n}\n\nQuerystring.prototype.rfc3986 = function (str) {\n  return str.replace(/[!'()*]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\nQuerystring.prototype.unescape = querystring.unescape\n\nexports.Querystring = Querystring\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosU0FBUyxtQkFBTyxDQUFDLGdEQUFJO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLGdDQUFhOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2VyRmlsZXNcXGdpZl9hcHBcXGdpZl9hcHBcXG5vZGVfbW9kdWxlc1xccmVxdWVzdFxcbGliXFxxdWVyeXN0cmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHFzID0gcmVxdWlyZSgncXMnKVxudmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxuXG5mdW5jdGlvbiBRdWVyeXN0cmluZyAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMubGliID0gbnVsbFxuICB0aGlzLnVzZVF1ZXJ5c3RyaW5nID0gbnVsbFxuICB0aGlzLnBhcnNlT3B0aW9ucyA9IG51bGxcbiAgdGhpcy5zdHJpbmdpZnlPcHRpb25zID0gbnVsbFxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICh0aGlzLmxpYikgeyByZXR1cm4gfVxuXG4gIHRoaXMudXNlUXVlcnlzdHJpbmcgPSBvcHRpb25zLnVzZVF1ZXJ5c3RyaW5nXG4gIHRoaXMubGliID0gKHRoaXMudXNlUXVlcnlzdHJpbmcgPyBxdWVyeXN0cmluZyA6IHFzKVxuXG4gIHRoaXMucGFyc2VPcHRpb25zID0gb3B0aW9ucy5xc1BhcnNlT3B0aW9ucyB8fCB7fVxuICB0aGlzLnN0cmluZ2lmeU9wdGlvbnMgPSBvcHRpb25zLnFzU3RyaW5naWZ5T3B0aW9ucyB8fCB7fVxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gKHRoaXMudXNlUXVlcnlzdHJpbmcpXG4gICAgPyB0aGlzLnJmYzM5ODYodGhpcy5saWIuc3RyaW5naWZ5KG9iaixcbiAgICAgIHRoaXMuc3RyaW5naWZ5T3B0aW9ucy5zZXAgfHwgbnVsbCxcbiAgICAgIHRoaXMuc3RyaW5naWZ5T3B0aW9ucy5lcSB8fCBudWxsLFxuICAgICAgdGhpcy5zdHJpbmdpZnlPcHRpb25zKSlcbiAgICA6IHRoaXMubGliLnN0cmluZ2lmeShvYmosIHRoaXMuc3RyaW5naWZ5T3B0aW9ucylcbn1cblxuUXVlcnlzdHJpbmcucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gKHRoaXMudXNlUXVlcnlzdHJpbmcpXG4gICAgPyB0aGlzLmxpYi5wYXJzZShzdHIsXG4gICAgICB0aGlzLnBhcnNlT3B0aW9ucy5zZXAgfHwgbnVsbCxcbiAgICAgIHRoaXMucGFyc2VPcHRpb25zLmVxIHx8IG51bGwsXG4gICAgICB0aGlzLnBhcnNlT3B0aW9ucylcbiAgICA6IHRoaXMubGliLnBhcnNlKHN0ciwgdGhpcy5wYXJzZU9wdGlvbnMpXG59XG5cblF1ZXJ5c3RyaW5nLnByb3RvdHlwZS5yZmMzOTg2ID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cblF1ZXJ5c3RyaW5nLnByb3RvdHlwZS51bmVzY2FwZSA9IHF1ZXJ5c3RyaW5nLnVuZXNjYXBlXG5cbmV4cG9ydHMuUXVlcnlzdHJpbmcgPSBRdWVyeXN0cmluZ1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/querystring.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/redirect.js":
/*!**********************************************!*\
  !*** ./node_modules/request/lib/redirect.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar url = __webpack_require__(/*! url */ \"url\")\nvar isUrl = /^https?:/\n\nfunction Redirect (request) {\n  this.request = request\n  this.followRedirect = true\n  this.followRedirects = true\n  this.followAllRedirects = false\n  this.followOriginalHttpMethod = false\n  this.allowRedirect = function () { return true }\n  this.maxRedirects = 10\n  this.redirects = []\n  this.redirectsFollowed = 0\n  this.removeRefererHeader = false\n}\n\nRedirect.prototype.onRequest = function (options) {\n  var self = this\n\n  if (options.maxRedirects !== undefined) {\n    self.maxRedirects = options.maxRedirects\n  }\n  if (typeof options.followRedirect === 'function') {\n    self.allowRedirect = options.followRedirect\n  }\n  if (options.followRedirect !== undefined) {\n    self.followRedirects = !!options.followRedirect\n  }\n  if (options.followAllRedirects !== undefined) {\n    self.followAllRedirects = options.followAllRedirects\n  }\n  if (self.followRedirects || self.followAllRedirects) {\n    self.redirects = self.redirects || []\n  }\n  if (options.removeRefererHeader !== undefined) {\n    self.removeRefererHeader = options.removeRefererHeader\n  }\n  if (options.followOriginalHttpMethod !== undefined) {\n    self.followOriginalHttpMethod = options.followOriginalHttpMethod\n  }\n}\n\nRedirect.prototype.redirectTo = function (response) {\n  var self = this\n  var request = self.request\n\n  var redirectTo = null\n  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {\n    var location = response.caseless.get('location')\n    request.debug('redirect', location)\n\n    if (self.followAllRedirects) {\n      redirectTo = location\n    } else if (self.followRedirects) {\n      switch (request.method) {\n        case 'PATCH':\n        case 'PUT':\n        case 'POST':\n        case 'DELETE':\n          // Do not follow redirects\n          break\n        default:\n          redirectTo = location\n          break\n      }\n    }\n  } else if (response.statusCode === 401) {\n    var authHeader = request._auth.onResponse(response)\n    if (authHeader) {\n      request.setHeader('authorization', authHeader)\n      redirectTo = request.uri\n    }\n  }\n  return redirectTo\n}\n\nRedirect.prototype.onResponse = function (response) {\n  var self = this\n  var request = self.request\n\n  var redirectTo = self.redirectTo(response)\n  if (!redirectTo || !self.allowRedirect.call(request, response)) {\n    return false\n  }\n\n  request.debug('redirect to', redirectTo)\n\n  // ignore any potential response body.  it cannot possibly be useful\n  // to us at this point.\n  // response.resume should be defined, but check anyway before calling. Workaround for browserify.\n  if (response.resume) {\n    response.resume()\n  }\n\n  if (self.redirectsFollowed >= self.maxRedirects) {\n    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))\n    return false\n  }\n  self.redirectsFollowed += 1\n\n  if (!isUrl.test(redirectTo)) {\n    redirectTo = url.resolve(request.uri.href, redirectTo)\n  }\n\n  var uriPrev = request.uri\n  request.uri = url.parse(redirectTo)\n\n  // handle the case where we change protocol from https to http or vice versa\n  if (request.uri.protocol !== uriPrev.protocol) {\n    delete request.agent\n  }\n\n  self.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo })\n\n  if (self.followAllRedirects && request.method !== 'HEAD' &&\n    response.statusCode !== 401 && response.statusCode !== 307) {\n    request.method = self.followOriginalHttpMethod ? request.method : 'GET'\n  }\n  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215\n  delete request.src\n  delete request.req\n  delete request._started\n  if (response.statusCode !== 401 && response.statusCode !== 307) {\n    // Remove parameters from the previous response, unless this is the second request\n    // for a server that requires digest authentication.\n    delete request.body\n    delete request._form\n    if (request.headers) {\n      request.removeHeader('host')\n      request.removeHeader('content-type')\n      request.removeHeader('content-length')\n      if (request.uri.hostname !== request.originalHost.split(':')[0]) {\n        // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of curl:\n        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710\n        request.removeHeader('authorization')\n      }\n    }\n  }\n\n  if (!self.removeRefererHeader) {\n    request.setHeader('referer', uriPrev.href)\n  }\n\n  request.emit('redirect')\n\n  request.init()\n\n  return true\n}\n\nexports.Redirect = Redirect\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvcmVkaXJlY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwwREFBMEQ7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJGaWxlc1xcZ2lmX2FwcFxcZ2lmX2FwcFxcbm9kZV9tb2R1bGVzXFxyZXF1ZXN0XFxsaWJcXHJlZGlyZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciBpc1VybCA9IC9eaHR0cHM/Oi9cblxuZnVuY3Rpb24gUmVkaXJlY3QgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLmZvbGxvd1JlZGlyZWN0ID0gdHJ1ZVxuICB0aGlzLmZvbGxvd1JlZGlyZWN0cyA9IHRydWVcbiAgdGhpcy5mb2xsb3dBbGxSZWRpcmVjdHMgPSBmYWxzZVxuICB0aGlzLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA9IGZhbHNlXG4gIHRoaXMuYWxsb3dSZWRpcmVjdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfVxuICB0aGlzLm1heFJlZGlyZWN0cyA9IDEwXG4gIHRoaXMucmVkaXJlY3RzID0gW11cbiAgdGhpcy5yZWRpcmVjdHNGb2xsb3dlZCA9IDBcbiAgdGhpcy5yZW1vdmVSZWZlcmVySGVhZGVyID0gZmFsc2Vcbn1cblxuUmVkaXJlY3QucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChvcHRpb25zLm1heFJlZGlyZWN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5tYXhSZWRpcmVjdHMgPSBvcHRpb25zLm1heFJlZGlyZWN0c1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mb2xsb3dSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuYWxsb3dSZWRpcmVjdCA9IG9wdGlvbnMuZm9sbG93UmVkaXJlY3RcbiAgfVxuICBpZiAob3B0aW9ucy5mb2xsb3dSZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5mb2xsb3dSZWRpcmVjdHMgPSAhIW9wdGlvbnMuZm9sbG93UmVkaXJlY3RcbiAgfVxuICBpZiAob3B0aW9ucy5mb2xsb3dBbGxSZWRpcmVjdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzID0gb3B0aW9ucy5mb2xsb3dBbGxSZWRpcmVjdHNcbiAgfVxuICBpZiAoc2VsZi5mb2xsb3dSZWRpcmVjdHMgfHwgc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICBzZWxmLnJlZGlyZWN0cyA9IHNlbGYucmVkaXJlY3RzIHx8IFtdXG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlUmVmZXJlckhlYWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5yZW1vdmVSZWZlcmVySGVhZGVyID0gb3B0aW9ucy5yZW1vdmVSZWZlcmVySGVhZGVyXG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9sbG93T3JpZ2luYWxIdHRwTWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA9IG9wdGlvbnMuZm9sbG93T3JpZ2luYWxIdHRwTWV0aG9kXG4gIH1cbn1cblxuUmVkaXJlY3QucHJvdG90eXBlLnJlZGlyZWN0VG8gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXF1ZXN0ID0gc2VsZi5yZXF1ZXN0XG5cbiAgdmFyIHJlZGlyZWN0VG8gPSBudWxsXG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCAmJiByZXNwb25zZS5zdGF0dXNDb2RlIDwgNDAwICYmIHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnbG9jYXRpb24nKSkge1xuICAgIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmNhc2VsZXNzLmdldCgnbG9jYXRpb24nKVxuICAgIHJlcXVlc3QuZGVidWcoJ3JlZGlyZWN0JywgbG9jYXRpb24pXG5cbiAgICBpZiAoc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICAgIHJlZGlyZWN0VG8gPSBsb2NhdGlvblxuICAgIH0gZWxzZSBpZiAoc2VsZi5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgY2FzZSAnUEFUQ0gnOlxuICAgICAgICBjYXNlICdQVVQnOlxuICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgICAvLyBEbyBub3QgZm9sbG93IHJlZGlyZWN0c1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVkaXJlY3RUbyA9IGxvY2F0aW9uXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgdmFyIGF1dGhIZWFkZXIgPSByZXF1ZXN0Ll9hdXRoLm9uUmVzcG9uc2UocmVzcG9uc2UpXG4gICAgaWYgKGF1dGhIZWFkZXIpIHtcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXV0aEhlYWRlcilcbiAgICAgIHJlZGlyZWN0VG8gPSByZXF1ZXN0LnVyaVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVkaXJlY3RUb1xufVxuXG5SZWRpcmVjdC5wcm90b3R5cGUub25SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICB2YXIgcmVkaXJlY3RUbyA9IHNlbGYucmVkaXJlY3RUbyhyZXNwb25zZSlcbiAgaWYgKCFyZWRpcmVjdFRvIHx8ICFzZWxmLmFsbG93UmVkaXJlY3QuY2FsbChyZXF1ZXN0LCByZXNwb25zZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJlcXVlc3QuZGVidWcoJ3JlZGlyZWN0IHRvJywgcmVkaXJlY3RUbylcblxuICAvLyBpZ25vcmUgYW55IHBvdGVudGlhbCByZXNwb25zZSBib2R5LiAgaXQgY2Fubm90IHBvc3NpYmx5IGJlIHVzZWZ1bFxuICAvLyB0byB1cyBhdCB0aGlzIHBvaW50LlxuICAvLyByZXNwb25zZS5yZXN1bWUgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBjaGVjayBhbnl3YXkgYmVmb3JlIGNhbGxpbmcuIFdvcmthcm91bmQgZm9yIGJyb3dzZXJpZnkuXG4gIGlmIChyZXNwb25zZS5yZXN1bWUpIHtcbiAgICByZXNwb25zZS5yZXN1bWUoKVxuICB9XG5cbiAgaWYgKHNlbGYucmVkaXJlY3RzRm9sbG93ZWQgPj0gc2VsZi5tYXhSZWRpcmVjdHMpIHtcbiAgICByZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdFeGNlZWRlZCBtYXhSZWRpcmVjdHMuIFByb2JhYmx5IHN0dWNrIGluIGEgcmVkaXJlY3QgbG9vcCAnICsgcmVxdWVzdC51cmkuaHJlZikpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc2VsZi5yZWRpcmVjdHNGb2xsb3dlZCArPSAxXG5cbiAgaWYgKCFpc1VybC50ZXN0KHJlZGlyZWN0VG8pKSB7XG4gICAgcmVkaXJlY3RUbyA9IHVybC5yZXNvbHZlKHJlcXVlc3QudXJpLmhyZWYsIHJlZGlyZWN0VG8pXG4gIH1cblxuICB2YXIgdXJpUHJldiA9IHJlcXVlc3QudXJpXG4gIHJlcXVlc3QudXJpID0gdXJsLnBhcnNlKHJlZGlyZWN0VG8pXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGNoYW5nZSBwcm90b2NvbCBmcm9tIGh0dHBzIHRvIGh0dHAgb3IgdmljZSB2ZXJzYVxuICBpZiAocmVxdWVzdC51cmkucHJvdG9jb2wgIT09IHVyaVByZXYucHJvdG9jb2wpIHtcbiAgICBkZWxldGUgcmVxdWVzdC5hZ2VudFxuICB9XG5cbiAgc2VsZi5yZWRpcmVjdHMucHVzaCh7IHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlZGlyZWN0VXJpOiByZWRpcmVjdFRvIH0pXG5cbiAgaWYgKHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiZcbiAgICByZXNwb25zZS5zdGF0dXNDb2RlICE9PSA0MDEgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMzA3KSB7XG4gICAgcmVxdWVzdC5tZXRob2QgPSBzZWxmLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA/IHJlcXVlc3QubWV0aG9kIDogJ0dFVCdcbiAgfVxuICAvLyByZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnIC8vIEZvcmNlIGFsbCByZWRpcmVjdHMgdG8gdXNlIEdFVCB8fCBjb21tZW50ZWQgb3V0IGZpeGVzICMyMTVcbiAgZGVsZXRlIHJlcXVlc3Quc3JjXG4gIGRlbGV0ZSByZXF1ZXN0LnJlcVxuICBkZWxldGUgcmVxdWVzdC5fc3RhcnRlZFxuICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gNDAxICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDMwNykge1xuICAgIC8vIFJlbW92ZSBwYXJhbWV0ZXJzIGZyb20gdGhlIHByZXZpb3VzIHJlc3BvbnNlLCB1bmxlc3MgdGhpcyBpcyB0aGUgc2Vjb25kIHJlcXVlc3RcbiAgICAvLyBmb3IgYSBzZXJ2ZXIgdGhhdCByZXF1aXJlcyBkaWdlc3QgYXV0aGVudGljYXRpb24uXG4gICAgZGVsZXRlIHJlcXVlc3QuYm9keVxuICAgIGRlbGV0ZSByZXF1ZXN0Ll9mb3JtXG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycykge1xuICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2hvc3QnKVxuICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG4gICAgICByZXF1ZXN0LnJlbW92ZUhlYWRlcignY29udGVudC1sZW5ndGgnKVxuICAgICAgaWYgKHJlcXVlc3QudXJpLmhvc3RuYW1lICE9PSByZXF1ZXN0Lm9yaWdpbmFsSG9zdC5zcGxpdCgnOicpWzBdKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhdXRob3JpemF0aW9uIGlmIGNoYW5naW5nIGhvc3RuYW1lcyAoYnV0IG5vdCBpZiBqdXN0XG4gICAgICAgIC8vIGNoYW5naW5nIHBvcnRzIG9yIHByb3RvY29scykuICBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW9yIG9mIGN1cmw6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWdkZXIvY3VybC9ibG9iLzZiZWIwZWVlL2xpYi9odHRwLmMjTDcxMFxuICAgICAgICByZXF1ZXN0LnJlbW92ZUhlYWRlcignYXV0aG9yaXphdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzZWxmLnJlbW92ZVJlZmVyZXJIZWFkZXIpIHtcbiAgICByZXF1ZXN0LnNldEhlYWRlcigncmVmZXJlcicsIHVyaVByZXYuaHJlZilcbiAgfVxuXG4gIHJlcXVlc3QuZW1pdCgncmVkaXJlY3QnKVxuXG4gIHJlcXVlc3QuaW5pdCgpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5SZWRpcmVjdCA9IFJlZGlyZWN0XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/redirect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/lib/tunnel.js":
/*!********************************************!*\
  !*** ./node_modules/request/lib/tunnel.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar url = __webpack_require__(/*! url */ \"url\")\nvar tunnel = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\")\n\nvar defaultProxyHeaderWhiteList = [\n  'accept',\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept-ranges',\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-md5',\n  'content-range',\n  'content-type',\n  'connection',\n  'date',\n  'expect',\n  'max-forwards',\n  'pragma',\n  'referer',\n  'te',\n  'user-agent',\n  'via'\n]\n\nvar defaultProxyHeaderExclusiveList = [\n  'proxy-authorization'\n]\n\nfunction constructProxyHost (uriObject) {\n  var port = uriObject.port\n  var protocol = uriObject.protocol\n  var proxyHost = uriObject.hostname + ':'\n\n  if (port) {\n    proxyHost += port\n  } else if (protocol === 'https:') {\n    proxyHost += '443'\n  } else {\n    proxyHost += '80'\n  }\n\n  return proxyHost\n}\n\nfunction constructProxyHeaderWhiteList (headers, proxyHeaderWhiteList) {\n  var whiteList = proxyHeaderWhiteList\n    .reduce(function (set, header) {\n      set[header.toLowerCase()] = true\n      return set\n    }, {})\n\n  return Object.keys(headers)\n    .filter(function (header) {\n      return whiteList[header.toLowerCase()]\n    })\n    .reduce(function (set, header) {\n      set[header] = headers[header]\n      return set\n    }, {})\n}\n\nfunction constructTunnelOptions (request, proxyHeaders) {\n  var proxy = request.proxy\n\n  var tunnelOptions = {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders\n    },\n    headers: request.headers,\n    ca: request.ca,\n    cert: request.cert,\n    key: request.key,\n    passphrase: request.passphrase,\n    pfx: request.pfx,\n    ciphers: request.ciphers,\n    rejectUnauthorized: request.rejectUnauthorized,\n    secureOptions: request.secureOptions,\n    secureProtocol: request.secureProtocol\n  }\n\n  return tunnelOptions\n}\n\nfunction constructTunnelFnName (uri, proxy) {\n  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')\n  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')\n  return [uriProtocol, proxyProtocol].join('Over')\n}\n\nfunction getTunnelFn (request) {\n  var uri = request.uri\n  var proxy = request.proxy\n  var tunnelFnName = constructTunnelFnName(uri, proxy)\n  return tunnel[tunnelFnName]\n}\n\nfunction Tunnel (request) {\n  this.request = request\n  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList\n  this.proxyHeaderExclusiveList = []\n  if (typeof request.tunnel !== 'undefined') {\n    this.tunnelOverride = request.tunnel\n  }\n}\n\nTunnel.prototype.isEnabled = function () {\n  var self = this\n  var request = self.request\n    // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If self.tunnelOverride is set (the user specified a value), use it.\n  if (typeof self.tunnelOverride !== 'undefined') {\n    return self.tunnelOverride\n  }\n\n  // If the destination is HTTPS, tunnel.\n  if (request.uri.protocol === 'https:') {\n    return true\n  }\n\n  // Otherwise, do not use tunnel.\n  return false\n}\n\nTunnel.prototype.setup = function (options) {\n  var self = this\n  var request = self.request\n\n  options = options || {}\n\n  if (typeof request.proxy === 'string') {\n    request.proxy = url.parse(request.proxy)\n  }\n\n  if (!request.proxy || !request.tunnel) {\n    return false\n  }\n\n  // Setup Proxy Header Exclusive List and White List\n  if (options.proxyHeaderWhiteList) {\n    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList\n  }\n  if (options.proxyHeaderExclusiveList) {\n    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList\n  }\n\n  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)\n  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)\n\n  // Setup Proxy Headers and Proxy Headers Host\n  // Only send the Proxy White Listed Header names\n  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)\n  proxyHeaders.host = constructProxyHost(request.uri)\n\n  proxyHeaderExclusiveList.forEach(request.removeHeader, request)\n\n  // Set Agent from Tunnel Data\n  var tunnelFn = getTunnelFn(request)\n  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)\n  request.agent = tunnelFn(tunnelOptions)\n\n  return true\n}\n\nTunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList\nTunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\nexports.Tunnel = Tunnel\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvdHVubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixhQUFhLG1CQUFPLENBQUMsZ0VBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIkM6XFxVc2VyRmlsZXNcXGdpZl9hcHBcXGdpZl9hcHBcXG5vZGVfbW9kdWxlc1xccmVxdWVzdFxcbGliXFx0dW5uZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxudmFyIHR1bm5lbCA9IHJlcXVpcmUoJ3R1bm5lbC1hZ2VudCcpXG5cbnZhciBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBbXG4gICdhY2NlcHQnLFxuICAnYWNjZXB0LWNoYXJzZXQnLFxuICAnYWNjZXB0LWVuY29kaW5nJyxcbiAgJ2FjY2VwdC1sYW5ndWFnZScsXG4gICdhY2NlcHQtcmFuZ2VzJyxcbiAgJ2NhY2hlLWNvbnRyb2wnLFxuICAnY29udGVudC1lbmNvZGluZycsXG4gICdjb250ZW50LWxhbmd1YWdlJyxcbiAgJ2NvbnRlbnQtbG9jYXRpb24nLFxuICAnY29udGVudC1tZDUnLFxuICAnY29udGVudC1yYW5nZScsXG4gICdjb250ZW50LXR5cGUnLFxuICAnY29ubmVjdGlvbicsXG4gICdkYXRlJyxcbiAgJ2V4cGVjdCcsXG4gICdtYXgtZm9yd2FyZHMnLFxuICAncHJhZ21hJyxcbiAgJ3JlZmVyZXInLFxuICAndGUnLFxuICAndXNlci1hZ2VudCcsXG4gICd2aWEnXG5dXG5cbnZhciBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gW1xuICAncHJveHktYXV0aG9yaXphdGlvbidcbl1cblxuZnVuY3Rpb24gY29uc3RydWN0UHJveHlIb3N0ICh1cmlPYmplY3QpIHtcbiAgdmFyIHBvcnQgPSB1cmlPYmplY3QucG9ydFxuICB2YXIgcHJvdG9jb2wgPSB1cmlPYmplY3QucHJvdG9jb2xcbiAgdmFyIHByb3h5SG9zdCA9IHVyaU9iamVjdC5ob3N0bmFtZSArICc6J1xuXG4gIGlmIChwb3J0KSB7XG4gICAgcHJveHlIb3N0ICs9IHBvcnRcbiAgfSBlbHNlIGlmIChwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwcm94eUhvc3QgKz0gJzQ0MydcbiAgfSBlbHNlIHtcbiAgICBwcm94eUhvc3QgKz0gJzgwJ1xuICB9XG5cbiAgcmV0dXJuIHByb3h5SG9zdFxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm94eUhlYWRlcldoaXRlTGlzdCAoaGVhZGVycywgcHJveHlIZWFkZXJXaGl0ZUxpc3QpIHtcbiAgdmFyIHdoaXRlTGlzdCA9IHByb3h5SGVhZGVyV2hpdGVMaXN0XG4gICAgLnJlZHVjZShmdW5jdGlvbiAoc2V0LCBoZWFkZXIpIHtcbiAgICAgIHNldFtoZWFkZXIudG9Mb3dlckNhc2UoKV0gPSB0cnVlXG4gICAgICByZXR1cm4gc2V0XG4gICAgfSwge30pXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gd2hpdGVMaXN0W2hlYWRlci50b0xvd2VyQ2FzZSgpXVxuICAgIH0pXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoc2V0LCBoZWFkZXIpIHtcbiAgICAgIHNldFtoZWFkZXJdID0gaGVhZGVyc1toZWFkZXJdXG4gICAgICByZXR1cm4gc2V0XG4gICAgfSwge30pXG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFR1bm5lbE9wdGlvbnMgKHJlcXVlc3QsIHByb3h5SGVhZGVycykge1xuICB2YXIgcHJveHkgPSByZXF1ZXN0LnByb3h5XG5cbiAgdmFyIHR1bm5lbE9wdGlvbnMgPSB7XG4gICAgcHJveHk6IHtcbiAgICAgIGhvc3Q6IHByb3h5Lmhvc3RuYW1lLFxuICAgICAgcG9ydDogK3Byb3h5LnBvcnQsXG4gICAgICBwcm94eUF1dGg6IHByb3h5LmF1dGgsXG4gICAgICBoZWFkZXJzOiBwcm94eUhlYWRlcnNcbiAgICB9LFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICBjYTogcmVxdWVzdC5jYSxcbiAgICBjZXJ0OiByZXF1ZXN0LmNlcnQsXG4gICAga2V5OiByZXF1ZXN0LmtleSxcbiAgICBwYXNzcGhyYXNlOiByZXF1ZXN0LnBhc3NwaHJhc2UsXG4gICAgcGZ4OiByZXF1ZXN0LnBmeCxcbiAgICBjaXBoZXJzOiByZXF1ZXN0LmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiByZXF1ZXN0LnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBzZWN1cmVPcHRpb25zOiByZXF1ZXN0LnNlY3VyZU9wdGlvbnMsXG4gICAgc2VjdXJlUHJvdG9jb2w6IHJlcXVlc3Quc2VjdXJlUHJvdG9jb2xcbiAgfVxuXG4gIHJldHVybiB0dW5uZWxPcHRpb25zXG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFR1bm5lbEZuTmFtZSAodXJpLCBwcm94eSkge1xuICB2YXIgdXJpUHJvdG9jb2wgPSAodXJpLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICdodHRwcycgOiAnaHR0cCcpXG4gIHZhciBwcm94eVByb3RvY29sID0gKHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6JyA/ICdIdHRwcycgOiAnSHR0cCcpXG4gIHJldHVybiBbdXJpUHJvdG9jb2wsIHByb3h5UHJvdG9jb2xdLmpvaW4oJ092ZXInKVxufVxuXG5mdW5jdGlvbiBnZXRUdW5uZWxGbiAocmVxdWVzdCkge1xuICB2YXIgdXJpID0gcmVxdWVzdC51cmlcbiAgdmFyIHByb3h5ID0gcmVxdWVzdC5wcm94eVxuICB2YXIgdHVubmVsRm5OYW1lID0gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpXG4gIHJldHVybiB0dW5uZWxbdHVubmVsRm5OYW1lXVxufVxuXG5mdW5jdGlvbiBUdW5uZWwgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLnByb3h5SGVhZGVyV2hpdGVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0XG4gIHRoaXMucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gW11cbiAgaWYgKHR5cGVvZiByZXF1ZXN0LnR1bm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnR1bm5lbE92ZXJyaWRlID0gcmVxdWVzdC50dW5uZWxcbiAgfVxufVxuXG5UdW5uZWwucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXF1ZXN0ID0gc2VsZi5yZXF1ZXN0XG4gICAgLy8gVHVubmVsIEhUVFBTIGJ5IGRlZmF1bHQuIEFsbG93IHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoaXMgc2V0dGluZy5cblxuICAvLyBJZiBzZWxmLnR1bm5lbE92ZXJyaWRlIGlzIHNldCAodGhlIHVzZXIgc3BlY2lmaWVkIGEgdmFsdWUpLCB1c2UgaXQuXG4gIGlmICh0eXBlb2Ygc2VsZi50dW5uZWxPdmVycmlkZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZi50dW5uZWxPdmVycmlkZVxuICB9XG5cbiAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIGlzIEhUVFBTLCB0dW5uZWwuXG4gIGlmIChyZXF1ZXN0LnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgdXNlIHR1bm5lbC5cbiAgcmV0dXJuIGZhbHNlXG59XG5cblR1bm5lbC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICh0eXBlb2YgcmVxdWVzdC5wcm94eSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXF1ZXN0LnByb3h5ID0gdXJsLnBhcnNlKHJlcXVlc3QucHJveHkpXG4gIH1cblxuICBpZiAoIXJlcXVlc3QucHJveHkgfHwgIXJlcXVlc3QudHVubmVsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBTZXR1cCBQcm94eSBIZWFkZXIgRXhjbHVzaXZlIExpc3QgYW5kIFdoaXRlIExpc3RcbiAgaWYgKG9wdGlvbnMucHJveHlIZWFkZXJXaGl0ZUxpc3QpIHtcbiAgICBzZWxmLnByb3h5SGVhZGVyV2hpdGVMaXN0ID0gb3B0aW9ucy5wcm94eUhlYWRlcldoaXRlTGlzdFxuICB9XG4gIGlmIChvcHRpb25zLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCkge1xuICAgIHNlbGYucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gb3B0aW9ucy5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3RcbiAgfVxuXG4gIHZhciBwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBzZWxmLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5jb25jYXQoZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdClcbiAgdmFyIHByb3h5SGVhZGVyV2hpdGVMaXN0ID0gc2VsZi5wcm94eUhlYWRlcldoaXRlTGlzdC5jb25jYXQocHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0KVxuXG4gIC8vIFNldHVwIFByb3h5IEhlYWRlcnMgYW5kIFByb3h5IEhlYWRlcnMgSG9zdFxuICAvLyBPbmx5IHNlbmQgdGhlIFByb3h5IFdoaXRlIExpc3RlZCBIZWFkZXIgbmFtZXNcbiAgdmFyIHByb3h5SGVhZGVycyA9IGNvbnN0cnVjdFByb3h5SGVhZGVyV2hpdGVMaXN0KHJlcXVlc3QuaGVhZGVycywgcHJveHlIZWFkZXJXaGl0ZUxpc3QpXG4gIHByb3h5SGVhZGVycy5ob3N0ID0gY29uc3RydWN0UHJveHlIb3N0KHJlcXVlc3QudXJpKVxuXG4gIHByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdC5mb3JFYWNoKHJlcXVlc3QucmVtb3ZlSGVhZGVyLCByZXF1ZXN0KVxuXG4gIC8vIFNldCBBZ2VudCBmcm9tIFR1bm5lbCBEYXRhXG4gIHZhciB0dW5uZWxGbiA9IGdldFR1bm5lbEZuKHJlcXVlc3QpXG4gIHZhciB0dW5uZWxPcHRpb25zID0gY29uc3RydWN0VHVubmVsT3B0aW9ucyhyZXF1ZXN0LCBwcm94eUhlYWRlcnMpXG4gIHJlcXVlc3QuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKVxuXG4gIHJldHVybiB0cnVlXG59XG5cblR1bm5lbC5kZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3RcblR1bm5lbC5kZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdFxuZXhwb3J0cy5UdW5uZWwgPSBUdW5uZWxcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/lib/tunnel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/request/request.js":
/*!*****************************************!*\
  !*** ./node_modules/request/request.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar http = __webpack_require__(/*! http */ \"http\")\nvar https = __webpack_require__(/*! https */ \"https\")\nvar url = __webpack_require__(/*! url */ \"url\")\nvar util = __webpack_require__(/*! util */ \"util\")\nvar stream = __webpack_require__(/*! stream */ \"stream\")\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\")\nvar aws2 = __webpack_require__(/*! aws-sign2 */ \"(ssr)/./node_modules/aws-sign2/index.js\")\nvar aws4 = __webpack_require__(/*! aws4 */ \"(ssr)/./node_modules/aws4/aws4.js\")\nvar httpSignature = __webpack_require__(/*! http-signature */ \"(ssr)/./node_modules/http-signature/lib/index.js\")\nvar mime = __webpack_require__(/*! mime-types */ \"(ssr)/./node_modules/mime-types/index.js\")\nvar caseless = __webpack_require__(/*! caseless */ \"(ssr)/./node_modules/caseless/index.js\")\nvar ForeverAgent = __webpack_require__(/*! forever-agent */ \"(ssr)/./node_modules/forever-agent/index.js\")\nvar FormData = __webpack_require__(/*! form-data */ \"(ssr)/./node_modules/form-data/lib/form_data.js\")\nvar extend = __webpack_require__(/*! extend */ \"(ssr)/./node_modules/extend/index.js\")\nvar isstream = __webpack_require__(/*! isstream */ \"(ssr)/./node_modules/isstream/isstream.js\")\nvar isTypedArray = (__webpack_require__(/*! is-typedarray */ \"(ssr)/./node_modules/is-typedarray/index.js\").strict)\nvar helpers = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/request/lib/helpers.js\")\nvar cookies = __webpack_require__(/*! ./lib/cookies */ \"(ssr)/./node_modules/request/lib/cookies.js\")\nvar getProxyFromURI = __webpack_require__(/*! ./lib/getProxyFromURI */ \"(ssr)/./node_modules/request/lib/getProxyFromURI.js\")\nvar Querystring = (__webpack_require__(/*! ./lib/querystring */ \"(ssr)/./node_modules/request/lib/querystring.js\").Querystring)\nvar Har = (__webpack_require__(/*! ./lib/har */ \"(ssr)/./node_modules/request/lib/har.js\").Har)\nvar Auth = (__webpack_require__(/*! ./lib/auth */ \"(ssr)/./node_modules/request/lib/auth.js\").Auth)\nvar OAuth = (__webpack_require__(/*! ./lib/oauth */ \"(ssr)/./node_modules/request/lib/oauth.js\").OAuth)\nvar hawk = __webpack_require__(/*! ./lib/hawk */ \"(ssr)/./node_modules/request/lib/hawk.js\")\nvar Multipart = (__webpack_require__(/*! ./lib/multipart */ \"(ssr)/./node_modules/request/lib/multipart.js\").Multipart)\nvar Redirect = (__webpack_require__(/*! ./lib/redirect */ \"(ssr)/./node_modules/request/lib/redirect.js\").Redirect)\nvar Tunnel = (__webpack_require__(/*! ./lib/tunnel */ \"(ssr)/./node_modules/request/lib/tunnel.js\").Tunnel)\nvar now = __webpack_require__(/*! performance-now */ \"(ssr)/./node_modules/performance-now/lib/performance-now.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n\nvar safeStringify = helpers.safeStringify\nvar isReadStream = helpers.isReadStream\nvar toBase64 = helpers.toBase64\nvar defer = helpers.defer\nvar copy = helpers.copy\nvar version = helpers.version\nvar globalCookieJar = cookies.jar()\n\nvar globalPool = {}\n\nfunction filterForNonReserved (reserved, options) {\n  // Filter out properties that are not reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var notReserved = (reserved.indexOf(i) === -1)\n    if (notReserved) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\nfunction filterOutReservedFunctions (reserved, options) {\n  // Filter out properties that are functions and are reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var isReserved = !(reserved.indexOf(i) === -1)\n    var isFunction = (typeof options[i] === 'function')\n    if (!(isReserved && isFunction)) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\n// Return a simpler request object to allow serialization\nfunction requestToJSON () {\n  var self = this\n  return {\n    uri: self.uri,\n    method: self.method,\n    headers: self.headers\n  }\n}\n\n// Return a simpler response object to allow serialization\nfunction responseToJSON () {\n  var self = this\n  return {\n    statusCode: self.statusCode,\n    body: self.body,\n    headers: self.headers,\n    request: requestToJSON.call(self.request)\n  }\n}\n\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n\nutil.inherits(Request, stream.Stream)\n\n// Debugging\nRequest.debug = process.env.NODE_DEBUG && /\\brequest\\b/.test(process.env.NODE_DEBUG)\nfunction debug () {\n  if (Request.debug) {\n    console.error('REQUEST %s', util.format.apply(util, arguments))\n  }\n}\nRequest.prototype.debug = debug\n\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this\n  if (!options) {\n    options = {}\n  }\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  // Delete headers with value undefined since they break\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n  for (var headerName in self.headers) {\n    if (typeof self.headers[headerName] === 'undefined') {\n      delete self.headers[headerName]\n    }\n  }\n\n  caseless.httpify(self, self.headers)\n\n  if (!self.method) {\n    self.method = options.method || 'GET'\n  }\n  if (!self.localAddress) {\n    self.localAddress = options.localAddress\n  }\n\n  self._qs.init(options)\n\n  debug(options)\n  if (!self.pool && self.pool !== false) {\n    self.pool = globalPool\n  }\n  self.dests = self.dests || []\n  self.__isRequestRequest = true\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) {\n        return // Print a warning maybe?\n      }\n      self._callbackCalled = true\n      self._callback.apply(self, arguments)\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  // People use this property instead all the time, so support it\n  if (!self.uri && self.url) {\n    self.uri = self.url\n    delete self.url\n  }\n\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n  // specified as a relative path and is appended to baseUrl).\n  if (self.baseUrl) {\n    if (typeof self.baseUrl !== 'string') {\n      return self.emit('error', new Error('options.baseUrl must be a string'))\n    }\n\n    if (typeof self.uri !== 'string') {\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n    }\n\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n    }\n\n    // Handle all cases to make sure that there's only one slash between\n    // baseUrl and uri.\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri.slice(1)\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri\n    } else if (self.uri === '') {\n      self.uri = self.baseUrl\n    } else {\n      self.uri = self.baseUrl + '/' + self.uri\n    }\n    delete self.baseUrl\n  }\n\n  // A URI is needed by this point, emit error if we haven't been able to get one\n  if (!self.uri) {\n    return self.emit('error', new Error('options.uri is a required argument'))\n  }\n\n  // If a string URI/URL was given, parse it into a URL object\n  if (typeof self.uri === 'string') {\n    self.uri = url.parse(self.uri)\n  }\n\n  // Some URL objects are not from a URL parsed string and need href added\n  if (!self.uri.href) {\n    self.uri.href = url.format(self.uri)\n  }\n\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n  if (self.uri.protocol === 'unix:') {\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n  }\n\n  // Support Unix Sockets\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false\n  }\n\n  if (!self.uri.pathname) { self.uri.pathname = '/' }\n\n  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri)\n    var message = 'Invalid URI \"' + faultyUri + '\"'\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.'\n    }\n    // This error was fatal\n    self.abort()\n    return self.emit('error', new Error(message))\n  }\n\n  if (!self.hasOwnProperty('proxy')) {\n    self.proxy = getProxyFromURI(self.uri)\n  }\n\n  self.tunnel = self._tunnel.isEnabled()\n  if (self.proxy) {\n    self._tunnel.setup(options)\n  }\n\n  self._redirect.onRequest(options)\n\n  self.setHost = false\n  if (!self.hasHeader('host')) {\n    var hostHeaderName = self.originalHostHeaderName || 'host'\n    self.setHeader(hostHeaderName, self.uri.host)\n    // Drop :port suffix from Host header if known protocol.\n    if (self.uri.port) {\n      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||\n          (self.uri.port === '443' && self.uri.protocol === 'https:')) {\n        self.setHeader(hostHeaderName, self.uri.hostname)\n      }\n    }\n    self.setHost = true\n  }\n\n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.port) {\n    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.formData) {\n    var formData = options.formData\n    var requestForm = self.form()\n    var appendFormValue = function (key, value) {\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n        requestForm.append(key, value.value, value.options)\n      } else {\n        requestForm.append(key, value)\n      }\n    }\n    for (var formKey in formData) {\n      if (formData.hasOwnProperty(formKey)) {\n        var formValue = formData[formKey]\n        if (formValue instanceof Array) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j])\n          }\n        } else {\n          appendFormValue(formKey, formValue)\n        }\n      }\n    }\n  }\n\n  if (options.qs) {\n    self.qs(options.qs)\n  }\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || '')\n  }\n\n  if (self.path.length === 0) {\n    self.path = '/'\n  }\n\n  // Auth must happen last in case signing is dependent on other headers\n  if (options.aws) {\n    self.aws(options.aws)\n  }\n\n  if (options.hawk) {\n    self.hawk(options.hawk)\n  }\n\n  if (options.httpSignature) {\n    self.httpSignature(options.httpSignature)\n  }\n\n  if (options.auth) {\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n      options.auth.user = options.auth.username\n    }\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n      options.auth.pass = options.auth.password\n    }\n\n    self.auth(\n      options.auth.user,\n      options.auth.pass,\n      options.auth.sendImmediately,\n      options.auth.bearer\n    )\n  }\n\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\n    self.setHeader('accept-encoding', 'gzip, deflate')\n  }\n\n  if (self.uri.auth && !self.hasHeader('authorization')) {\n    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n  }\n\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n    self.setHeader('proxy-authorization', authHeader)\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n  }\n\n  if (options.json) {\n    self.json(options.json)\n  }\n  if (options.multipart) {\n    self.multipart(options.multipart)\n  }\n\n  if (options.time) {\n    self.timing = true\n\n    // NOTE: elapsedTime is deprecated in favor of .timings\n    self.elapsedTime = self.elapsedTime || 0\n  }\n\n  function setContentLength () {\n    if (isTypedArray(self.body)) {\n      self.body = Buffer.from(self.body)\n    }\n\n    if (!self.hasHeader('content-length')) {\n      var length\n      if (typeof self.body === 'string') {\n        length = Buffer.byteLength(self.body)\n      } else if (Array.isArray(self.body)) {\n        length = self.body.reduce(function (a, b) { return a + b.length }, 0)\n      } else {\n        length = self.body.length\n      }\n\n      if (length) {\n        self.setHeader('content-length', length)\n      } else {\n        self.emit('error', new Error('Argument error, options.body.'))\n      }\n    }\n  }\n  if (self.body && !isstream(self.body)) {\n    setContentLength()\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\n    self.oauth(self._oauth.params)\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n  var defaultModules = {'http:': http, 'https:': https}\n  var httpModules = self.httpModules || {}\n\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) {\n    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n  }\n\n  if (options.ca) {\n    self.ca = options.ca\n  }\n\n  if (!self.agent) {\n    if (options.agentOptions) {\n      self.agentOptions = options.agentOptions\n    }\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      var v = version()\n      // use ForeverAgent in node 0.10- only\n      if (v.major === 0 && v.minor <= 10) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n      } else {\n        self.agentClass = self.httpModule.Agent\n        self.agentOptions = self.agentOptions || {}\n        self.agentOptions.keepAlive = true\n      }\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getNewAgent()\n  }\n\n  self.on('pipe', function (src) {\n    if (self.ntick && self._started) {\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n    }\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', mime.lookup(src.path))\n      }\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.hasHeader(i)) {\n            self.setHeader(i, src.headers[i])\n          }\n        }\n      }\n      if (self._json && !self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n      if (src.method && !self.explicitMethod) {\n        self.method = src.method\n      }\n    }\n\n  // self.on('pipe', function () {\n  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n  // })\n  })\n\n  defer(function () {\n    if (self._aborted) {\n      return\n    }\n\n    var end = function () {\n      if (self._form) {\n        if (!self._auth.hasAuth) {\n          self._form.pipe(self)\n        } else if (self._auth.hasAuth && self._auth.sentAuth) {\n          self._form.pipe(self)\n        }\n      }\n      if (self._multipart && self._multipart.chunked) {\n        self._multipart.body.pipe(self)\n      }\n      if (self.body) {\n        if (isstream(self.body)) {\n          self.body.pipe(self)\n        } else {\n          setContentLength()\n          if (Array.isArray(self.body)) {\n            self.body.forEach(function (part) {\n              self.write(part)\n            })\n          } else {\n            self.write(self.body)\n          }\n          self.end()\n        }\n      } else if (self.requestBodyStream) {\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n        self.requestBodyStream.pipe(self)\n      } else if (!self.src) {\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\n          self.end()\n          return\n        }\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0)\n        }\n        self.end()\n      }\n    }\n\n    if (self._form && !self.hasHeader('content-length')) {\n      // Before ending the request, we had to compute the length of the whole form, asyncly\n      self.setHeader(self._form.getHeaders(), true)\n      self._form.getLength(function (err, length) {\n        if (!err && !isNaN(length)) {\n          self.setHeader('content-length', length)\n        }\n        end()\n      })\n    } else {\n      end()\n    }\n\n    self.ntick = true\n  })\n}\n\nRequest.prototype.getNewAgent = function () {\n  var self = this\n  var Agent = self.agentClass\n  var options = {}\n  if (self.agentOptions) {\n    for (var i in self.agentOptions) {\n      options[i] = self.agentOptions[i]\n    }\n  }\n  if (self.ca) {\n    options.ca = self.ca\n  }\n  if (self.ciphers) {\n    options.ciphers = self.ciphers\n  }\n  if (self.secureProtocol) {\n    options.secureProtocol = self.secureProtocol\n  }\n  if (self.secureOptions) {\n    options.secureOptions = self.secureOptions\n  }\n  if (typeof self.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = self.rejectUnauthorized\n  }\n\n  if (self.cert && self.key) {\n    options.key = self.key\n    options.cert = self.cert\n  }\n\n  if (self.pfx) {\n    options.pfx = self.pfx\n  }\n\n  if (self.passphrase) {\n    options.passphrase = self.passphrase\n  }\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== self.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = self.proxy\n  if (typeof proxy === 'string') {\n    proxy = url.parse(proxy)\n  }\n  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ca\n    }\n\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.rejectUnauthorized\n    }\n\n    if (options.cert) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n    }\n\n    if (options.pfx) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.pfx.toString('ascii')\n    }\n\n    if (options.ciphers) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ciphers\n    }\n\n    if (options.secureProtocol) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureProtocol\n    }\n\n    if (options.secureOptions) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureOptions\n    }\n  }\n\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return self.httpModule.globalAgent\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = self.uri.protocol + poolKey\n\n  // generate a new agent for this setting if none yet exists\n  if (!self.pool[poolKey]) {\n    self.pool[poolKey] = new Agent(options)\n    // properly set maxSockets on new agents\n    if (self.pool.maxSockets) {\n      self.pool[poolKey].maxSockets = self.pool.maxSockets\n    }\n  }\n\n  return self.pool[poolKey]\n}\n\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this\n\n  if (self.timing) {\n    // All timings will be relative to this request's startTime.  In order to do this,\n    // we need to capture the wall-clock start time (via Date), immediately followed\n    // by the high-resolution timer (via now()).  While these two won't be set\n    // at the _exact_ same time, they should be close enough to be able to calculate\n    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\n    var startTime = new Date().getTime()\n    var startTimeNow = now()\n  }\n\n  if (self._aborted) {\n    return\n  }\n\n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size)\n  }\n  if (self._aws) {\n    self.aws(self._aws, true)\n  }\n\n  // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n  var reqOptions = copy(self)\n  delete reqOptions.auth\n\n  debug('make request', self.uri.href)\n\n  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\n  // should delete it for now since we handle timeouts manually for better\n  // consistency with node versions before v6.8.0\n  delete reqOptions.timeout\n\n  try {\n    self.req = self.httpModule.request(reqOptions)\n  } catch (err) {\n    self.emit('error', err)\n    return\n  }\n\n  if (self.timing) {\n    self.startTime = startTime\n    self.startTimeNow = startTimeNow\n\n    // Timing values will all be relative to startTime (by comparing to startTimeNow\n    // so we have an accurate clock)\n    self.timings = {}\n  }\n\n  var timeout\n  if (self.timeout && !self.timeoutTimer) {\n    if (self.timeout < 0) {\n      timeout = 0\n    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\n      timeout = self.timeout\n    }\n  }\n\n  self.req.on('response', self.onRequestResponse.bind(self))\n  self.req.on('error', self.onRequestError.bind(self))\n  self.req.on('drain', function () {\n    self.emit('drain')\n  })\n\n  self.req.on('socket', function (socket) {\n    // `._connecting` was the old property which was made public in node v6.1.0\n    var isConnecting = socket._connecting || socket.connecting\n    if (self.timing) {\n      self.timings.socket = now() - self.startTimeNow\n\n      if (isConnecting) {\n        var onLookupTiming = function () {\n          self.timings.lookup = now() - self.startTimeNow\n        }\n\n        var onConnectTiming = function () {\n          self.timings.connect = now() - self.startTimeNow\n        }\n\n        socket.once('lookup', onLookupTiming)\n        socket.once('connect', onConnectTiming)\n\n        // clean up timing event listeners if needed on error\n        self.req.once('error', function () {\n          socket.removeListener('lookup', onLookupTiming)\n          socket.removeListener('connect', onConnectTiming)\n        })\n      }\n    }\n\n    var setReqTimeout = function () {\n      // This timeout sets the amount of time to wait *between* bytes sent\n      // from the server once connected.\n      //\n      // In particular, it's useful for erroring if the server fails to send\n      // data halfway through streaming a response.\n      self.req.setTimeout(timeout, function () {\n        if (self.req) {\n          self.abort()\n          var e = new Error('ESOCKETTIMEDOUT')\n          e.code = 'ESOCKETTIMEDOUT'\n          e.connect = false\n          self.emit('error', e)\n        }\n      })\n    }\n    if (timeout !== undefined) {\n      // Only start the connection timer if we're actually connecting a new\n      // socket, otherwise if we're already connected (because this is a\n      // keep-alive connection) do not bother. This is important since we won't\n      // get a 'connect' event for an already connected socket.\n      if (isConnecting) {\n        var onReqSockConnect = function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.clearTimeout()\n          setReqTimeout()\n        }\n\n        socket.on('connect', onReqSockConnect)\n\n        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err\n          socket.removeListener('connect', onReqSockConnect)\n        })\n\n        // Set a timeout in memory - this block will throw if the server takes more\n        // than `timeout` to write the HTTP status and headers (corresponding to\n        // the on('response') event on the client). NB: this measures wall-clock\n        // time, not the time between bytes sent by the server.\n        self.timeoutTimer = setTimeout(function () {\n          socket.removeListener('connect', onReqSockConnect)\n          self.abort()\n          var e = new Error('ETIMEDOUT')\n          e.code = 'ETIMEDOUT'\n          e.connect = true\n          self.emit('error', e)\n        }, timeout)\n      } else {\n        // We're already connected\n        setReqTimeout()\n      }\n    }\n    self.emit('socket', socket)\n  })\n\n  self.emit('request', self.req)\n}\n\nRequest.prototype.onRequestError = function (error) {\n  var self = this\n  if (self._aborted) {\n    return\n  }\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&\n    self.agent.addRequestNoreuse) {\n    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n    self.start()\n    self.req.end()\n    return\n  }\n  self.clearTimeout()\n  self.emit('error', error)\n}\n\nRequest.prototype.onRequestResponse = function (response) {\n  var self = this\n\n  if (self.timing) {\n    self.timings.response = now() - self.startTimeNow\n  }\n\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n  response.on('end', function () {\n    if (self.timing) {\n      self.timings.end = now() - self.startTimeNow\n      response.timingStart = self.startTime\n\n      // fill in the blanks for any periods that didn't trigger, such as\n      // no lookup or connect due to keep alive\n      if (!self.timings.socket) {\n        self.timings.socket = 0\n      }\n      if (!self.timings.lookup) {\n        self.timings.lookup = self.timings.socket\n      }\n      if (!self.timings.connect) {\n        self.timings.connect = self.timings.lookup\n      }\n      if (!self.timings.response) {\n        self.timings.response = self.timings.connect\n      }\n\n      debug('elapsed time', self.timings.end)\n\n      // elapsedTime includes all redirects\n      self.elapsedTime += Math.round(self.timings.end)\n\n      // NOTE: elapsedTime is deprecated in favor of .timings\n      response.elapsedTime = self.elapsedTime\n\n      // timings is just for the final fetch\n      response.timings = self.timings\n\n      // pre-calculate phase timings as well\n      response.timingPhases = {\n        wait: self.timings.socket,\n        dns: self.timings.lookup - self.timings.socket,\n        tcp: self.timings.connect - self.timings.lookup,\n        firstByte: self.timings.response - self.timings.connect,\n        download: self.timings.end - self.timings.response,\n        total: self.timings.end\n      }\n    }\n    debug('response end', self.uri.href, response.statusCode, response.headers)\n  })\n\n  if (self._aborted) {\n    debug('aborted', self.uri.href)\n    response.resume()\n    return\n  }\n\n  self.response = response\n  response.request = self\n  response.toJSON = responseToJSON\n\n  // XXX This is different on 0.10, because SSL is strict by default\n  if (self.httpModule === https &&\n    self.strictSSL && (!response.hasOwnProperty('socket') ||\n    !response.socket.authorized)) {\n    debug('strict ssl error', self.uri.href)\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n    self.emit('error', new Error('SSL Error: ' + sslErr))\n    return\n  }\n\n  // Save the original host before any redirect (if it changes, we need to\n  // remove any authorization headers).  Also remember the case of the header\n  // name because lots of broken servers expect Host instead of host and we\n  // want the caller to be able to specify this.\n  self.originalHost = self.getHeader('host')\n  if (!self.originalHostHeaderName) {\n    self.originalHostHeaderName = self.hasHeader('host')\n  }\n  if (self.setHost) {\n    self.removeHeader('host')\n  }\n  self.clearTimeout()\n\n  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n  var addCookie = function (cookie) {\n    // set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n    } catch (e) {\n      self.emit('error', e)\n    }\n  }\n\n  response.caseless = caseless(response.headers)\n\n  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n    var headerName = response.caseless.has('set-cookie')\n    if (Array.isArray(response.headers[headerName])) {\n      response.headers[headerName].forEach(addCookie)\n    } else {\n      addCookie(response.headers[headerName])\n    }\n  }\n\n  if (self._redirect.onResponse(response)) {\n    return // Ignore the rest of the response\n  } else {\n    // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n    response.on('close', function () {\n      if (!self._ended) {\n        self.response.emit('end')\n      }\n    })\n\n    response.once('end', function () {\n      self._ended = true\n    })\n\n    var noBody = function (code) {\n      return (\n        self.method === 'HEAD' ||\n        // Informational\n        (code >= 100 && code < 200) ||\n        // No Content\n        code === 204 ||\n        // Not Modified\n        code === 304\n      )\n    }\n\n    var responseContent\n    if (self.gzip && !noBody(response.statusCode)) {\n      var contentEncoding = response.headers['content-encoding'] || 'identity'\n      contentEncoding = contentEncoding.trim().toLowerCase()\n\n      // Be more lenient with decoding compressed responses, since (very rarely)\n      // servers send slightly invalid gzip responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      var zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }\n\n      if (contentEncoding === 'gzip') {\n        responseContent = zlib.createGunzip(zlibOptions)\n        response.pipe(responseContent)\n      } else if (contentEncoding === 'deflate') {\n        responseContent = zlib.createInflate(zlibOptions)\n        response.pipe(responseContent)\n      } else {\n        // Since previous versions didn't check for Content-Encoding header,\n        // ignore any invalid values to preserve backwards-compatibility\n        if (contentEncoding !== 'identity') {\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n        }\n        responseContent = response\n      }\n    } else {\n      responseContent = response\n    }\n\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n      } else {\n        responseContent.setEncoding(self.encoding)\n      }\n    }\n\n    if (self._paused) {\n      responseContent.pause()\n    }\n\n    self.responseContent = responseContent\n\n    self.emit('response', response)\n\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest)\n    })\n\n    responseContent.on('data', function (chunk) {\n      if (self.timing && !self.responseStarted) {\n        self.responseStartTime = (new Date()).getTime()\n\n        // NOTE: responseStartTime is deprecated in favor of .timings\n        response.responseStartTime = self.responseStartTime\n      }\n      self._destdata = true\n      self.emit('data', chunk)\n    })\n    responseContent.once('end', function (chunk) {\n      self.emit('end', chunk)\n    })\n    responseContent.on('error', function (error) {\n      self.emit('error', error)\n    })\n    responseContent.on('close', function () { self.emit('close') })\n\n    if (self.callback) {\n      self.readResponseBody(response)\n    } else { // if no callback\n      self.on('end', function () {\n        if (self._aborted) {\n          debug('aborted', self.uri.href)\n          return\n        }\n        self.emit('complete', response)\n      })\n    }\n  }\n  debug('finish init function', self.uri.href)\n}\n\nRequest.prototype.readResponseBody = function (response) {\n  var self = this\n  debug(\"reading response's body\")\n  var buffers = []\n  var bufferLength = 0\n  var strings = []\n\n  self.on('data', function (chunk) {\n    if (!Buffer.isBuffer(chunk)) {\n      strings.push(chunk)\n    } else if (chunk.length) {\n      bufferLength += chunk.length\n      buffers.push(chunk)\n    }\n  })\n  self.on('end', function () {\n    debug('end event', self.uri.href)\n    if (self._aborted) {\n      debug('aborted', self.uri.href)\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n      return\n    }\n\n    if (bufferLength) {\n      debug('has body', self.uri.href, bufferLength)\n      response.body = Buffer.concat(buffers, bufferLength)\n      if (self.encoding !== null) {\n        response.body = response.body.toString(self.encoding)\n      }\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffers = []\n      bufferLength = 0\n    } else if (strings.length) {\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n        strings[0] = strings[0].substring(1)\n      }\n      response.body = strings.join('')\n    }\n\n    if (self._json) {\n      try {\n        response.body = JSON.parse(response.body, self._jsonReviver)\n      } catch (e) {\n        debug('invalid JSON received', self.uri.href)\n      }\n    }\n    debug('emitting complete', self.uri.href)\n    if (typeof response.body === 'undefined' && !self._json) {\n      response.body = self.encoding === null ? Buffer.alloc(0) : ''\n    }\n    self.emit('complete', response, response.body)\n  })\n}\n\nRequest.prototype.abort = function () {\n  var self = this\n  self._aborted = true\n\n  if (self.req) {\n    self.req.abort()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n\n  self.clearTimeout()\n  self.emit('abort')\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var self = this\n  var response = self.response\n  // Called after the response is received\n  if (dest.headers && !dest.headersSent) {\n    if (response.caseless.has('content-type')) {\n      var ctname = response.caseless.has('content-type')\n      if (dest.setHeader) {\n        dest.setHeader(ctname, response.headers[ctname])\n      } else {\n        dest.headers[ctname] = response.headers[ctname]\n      }\n    }\n\n    if (response.caseless.has('content-length')) {\n      var clname = response.caseless.has('content-length')\n      if (dest.setHeader) {\n        dest.setHeader(clname, response.headers[clname])\n      } else {\n        dest.headers[clname] = response.headers[clname]\n      }\n    }\n  }\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      // If the response content is being decoded, the Content-Encoding header\n      // of the response doesn't represent the piped content, so don't pass it.\n      if (!self.gzip || i !== 'content-encoding') {\n        dest.setHeader(i, response.headers[i])\n      }\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (self.pipefilter) {\n    self.pipefilter(response, dest)\n  }\n}\n\nRequest.prototype.qs = function (q, clobber) {\n  var self = this\n  var base\n  if (!clobber && self.uri.query) {\n    base = self._qs.parse(self.uri.query)\n  } else {\n    base = {}\n  }\n\n  for (var i in q) {\n    base[i] = q[i]\n  }\n\n  var qs = self._qs.stringify(base)\n\n  if (qs === '') {\n    return self\n  }\n\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n  self.url = self.uri\n  self.path = self.uri.path\n\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  return self\n}\nRequest.prototype.form = function (form) {\n  var self = this\n  if (form) {\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n    }\n    self.body = (typeof form === 'string')\n      ? self._qs.rfc3986(form.toString('utf8'))\n      : self._qs.stringify(form).toString('utf8')\n    return self\n  }\n  // create form-data object\n  self._form = new FormData()\n  self._form.on('error', function (err) {\n    err.message = 'form-data: ' + err.message\n    self.emit('error', err)\n    self.abort()\n  })\n  return self._form\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n\n  self._multipart.onRequest(multipart)\n\n  if (!self._multipart.chunked) {\n    self.body = self._multipart.body\n  }\n\n  return self\n}\nRequest.prototype.json = function (val) {\n  var self = this\n\n  if (!self.hasHeader('accept')) {\n    self.setHeader('accept', 'application/json')\n  }\n\n  if (typeof self.jsonReplacer === 'function') {\n    self._jsonReplacer = self.jsonReplacer\n  }\n\n  self._json = true\n  if (typeof val === 'boolean') {\n    if (self.body !== undefined) {\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n        self.body = safeStringify(self.body, self._jsonReplacer)\n      } else {\n        self.body = self._qs.rfc3986(self.body)\n      }\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n    }\n  } else {\n    self.body = safeStringify(val, self._jsonReplacer)\n    if (!self.hasHeader('content-type')) {\n      self.setHeader('content-type', 'application/json')\n    }\n  }\n\n  if (typeof self.jsonReviver === 'function') {\n    self._jsonReviver = self.jsonReviver\n  }\n\n  return self\n}\nRequest.prototype.getHeader = function (name, headers) {\n  var self = this\n  var result, re, match\n  if (!headers) {\n    headers = self.headers\n  }\n  Object.keys(headers).forEach(function (key) {\n    if (key.length !== name.length) {\n      return\n    }\n    re = new RegExp(name, 'i')\n    match = key.match(re)\n    if (match) {\n      result = headers[key]\n    }\n  })\n  return result\n}\nRequest.prototype.enableUnixSocket = function () {\n  // Get the socket & request paths from the URL\n  var unixParts = this.uri.path.split(':')\n  var host = unixParts[0]\n  var path = unixParts[1]\n  // Apply unix properties to request\n  this.socketPath = host\n  this.uri.pathname = path\n  this.uri.path = path\n  this.uri.host = host\n  this.uri.hostname = host\n  this.uri.isUnix = true\n}\n\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n  var self = this\n\n  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n  return self\n}\nRequest.prototype.aws = function (opts, now) {\n  var self = this\n\n  if (!now) {\n    self._aws = opts\n    return self\n  }\n\n  if (opts.sign_version === 4 || opts.sign_version === '4') {\n    // use aws4\n    var options = {\n      host: self.uri.host,\n      path: self.uri.path,\n      method: self.method,\n      headers: self.headers,\n      body: self.body\n    }\n    if (opts.service) {\n      options.service = opts.service\n    }\n    var signRes = aws4.sign(options, {\n      accessKeyId: opts.key,\n      secretAccessKey: opts.secret,\n      sessionToken: opts.session\n    })\n    self.setHeader('authorization', signRes.headers.Authorization)\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n    if (signRes.headers['X-Amz-Security-Token']) {\n      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])\n    }\n  } else {\n    // default: use aws-sign2\n    var date = new Date()\n    self.setHeader('date', date.toUTCString())\n    var auth = {\n      key: opts.key,\n      secret: opts.secret,\n      verb: self.method.toUpperCase(),\n      date: date,\n      contentType: self.getHeader('content-type') || '',\n      md5: self.getHeader('content-md5') || '',\n      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n    }\n    var path = self.uri.path\n    if (opts.bucket && path) {\n      auth.resource = '/' + opts.bucket + path\n    } else if (opts.bucket && !path) {\n      auth.resource = '/' + opts.bucket\n    } else if (!opts.bucket && path) {\n      auth.resource = path\n    } else if (!opts.bucket && !path) {\n      auth.resource = '/'\n    }\n    auth.resource = aws2.canonicalizeResource(auth.resource)\n    self.setHeader('authorization', aws2.authorization(auth))\n  }\n\n  return self\n}\nRequest.prototype.httpSignature = function (opts) {\n  var self = this\n  httpSignature.signRequest({\n    getHeader: function (header) {\n      return self.getHeader(header, self.headers)\n    },\n    setHeader: function (header, value) {\n      self.setHeader(header, value)\n    },\n    method: self.method,\n    path: self.path\n  }, opts)\n  debug('httpSignature authorization', self.getHeader('authorization'))\n\n  return self\n}\nRequest.prototype.hawk = function (opts) {\n  var self = this\n  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))\n}\nRequest.prototype.oauth = function (_oauth) {\n  var self = this\n\n  self._oauth.onRequest(_oauth)\n\n  return self\n}\n\nRequest.prototype.jar = function (jar) {\n  var self = this\n  var cookies\n\n  if (self._redirect.redirectsFollowed === 0) {\n    self.originalCookieHeader = self.getHeader('cookie')\n  }\n\n  if (!jar) {\n    // disable cookies\n    cookies = false\n    self._disableCookies = true\n  } else {\n    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar\n    var urihref = self.uri.href\n    // fetch cookie in the Specified host\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref)\n    }\n  }\n\n  // if need cookie and cookie is not empty\n  if (cookies && cookies.length) {\n    if (self.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n    } else {\n      self.setHeader('cookie', cookies)\n    }\n  }\n  self._jar = jar\n  return self\n}\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  var self = this\n\n  if (self.response) {\n    if (self._destdata) {\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n    } else if (self._ended) {\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n    } else {\n      stream.Stream.prototype.pipe.call(self, dest, opts)\n      self.pipeDest(dest)\n      return dest\n    }\n  } else {\n    self.dests.push(dest)\n    stream.Stream.prototype.pipe.call(self, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  var self = this\n  if (self._aborted) { return }\n\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    return self.req.write.apply(self.req, arguments)\n  }\n}\nRequest.prototype.end = function (chunk) {\n  var self = this\n  if (self._aborted) { return }\n\n  if (chunk) {\n    self.write(chunk)\n  }\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    self.req.end()\n  }\n}\nRequest.prototype.pause = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = true\n  } else {\n    self.responseContent.pause.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.resume = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = false\n  } else {\n    self.responseContent.resume.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.destroy = function () {\n  var self = this\n  this.clearTimeout()\n  if (!self._ended) {\n    self.end()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n}\n\nRequest.prototype.clearTimeout = function () {\n  if (this.timeoutTimer) {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = null\n  }\n}\n\nRequest.defaultProxyHeaderWhiteList =\n  Tunnel.defaultProxyHeaderWhiteList.slice()\n\nRequest.defaultProxyHeaderExclusiveList =\n  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n// Exports\n\nRequest.prototype.toJSON = requestToJSON\nmodule.exports = Request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQywwREFBVztBQUM5QixXQUFXLG1CQUFPLENBQUMsK0NBQU07QUFDekIsb0JBQW9CLG1CQUFPLENBQUMsd0VBQWdCO0FBQzVDLFdBQVcsbUJBQU8sQ0FBQyw0REFBWTtBQUMvQixlQUFlLG1CQUFPLENBQUMsd0RBQVU7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsa0VBQWU7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxvREFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsMkRBQVU7QUFDakMsbUJBQW1CLGdHQUErQjtBQUNsRCxjQUFjLG1CQUFPLENBQUMsa0VBQWU7QUFDckMsY0FBYyxtQkFBTyxDQUFDLGtFQUFlO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUF1QjtBQUNyRCxrQkFBa0IsNkdBQXdDO0FBQzFELFVBQVUscUZBQXdCO0FBQ2xDLFdBQVcsd0ZBQTBCO0FBQ3JDLFlBQVksMkZBQTRCO0FBQ3hDLFdBQVcsbUJBQU8sQ0FBQyw0REFBWTtBQUMvQixnQkFBZ0IsdUdBQW9DO0FBQ3BELGVBQWUsb0dBQWtDO0FBQ2pELGFBQWEsOEZBQThCO0FBQzNDLFVBQVUsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDbkMsYUFBYSw0RkFBNkI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxxQkFBcUIsMkNBQTJDO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFLGdDQUFnQztBQUN2RztBQUNBOztBQUVBO0FBQ0EsMkVBQTJFLGdDQUFnQztBQUMzRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvREFBb0QscUJBQXFCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUUsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEMsb0JBQW9COztBQUVsRTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2VyRmlsZXNcXGdpZl9hcHBcXGdpZl9hcHBcXG5vZGVfbW9kdWxlc1xccmVxdWVzdFxccmVxdWVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxudmFyIHpsaWIgPSByZXF1aXJlKCd6bGliJylcbnZhciBhd3MyID0gcmVxdWlyZSgnYXdzLXNpZ24yJylcbnZhciBhd3M0ID0gcmVxdWlyZSgnYXdzNCcpXG52YXIgaHR0cFNpZ25hdHVyZSA9IHJlcXVpcmUoJ2h0dHAtc2lnbmF0dXJlJylcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpXG52YXIgY2FzZWxlc3MgPSByZXF1aXJlKCdjYXNlbGVzcycpXG52YXIgRm9yZXZlckFnZW50ID0gcmVxdWlyZSgnZm9yZXZlci1hZ2VudCcpXG52YXIgRm9ybURhdGEgPSByZXF1aXJlKCdmb3JtLWRhdGEnKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZCcpXG52YXIgaXNzdHJlYW0gPSByZXF1aXJlKCdpc3N0cmVhbScpXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWRhcnJheScpLnN0cmljdFxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2xpYi9oZWxwZXJzJylcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi9saWIvY29va2llcycpXG52YXIgZ2V0UHJveHlGcm9tVVJJID0gcmVxdWlyZSgnLi9saWIvZ2V0UHJveHlGcm9tVVJJJylcbnZhciBRdWVyeXN0cmluZyA9IHJlcXVpcmUoJy4vbGliL3F1ZXJ5c3RyaW5nJykuUXVlcnlzdHJpbmdcbnZhciBIYXIgPSByZXF1aXJlKCcuL2xpYi9oYXInKS5IYXJcbnZhciBBdXRoID0gcmVxdWlyZSgnLi9saWIvYXV0aCcpLkF1dGhcbnZhciBPQXV0aCA9IHJlcXVpcmUoJy4vbGliL29hdXRoJykuT0F1dGhcbnZhciBoYXdrID0gcmVxdWlyZSgnLi9saWIvaGF3aycpXG52YXIgTXVsdGlwYXJ0ID0gcmVxdWlyZSgnLi9saWIvbXVsdGlwYXJ0JykuTXVsdGlwYXJ0XG52YXIgUmVkaXJlY3QgPSByZXF1aXJlKCcuL2xpYi9yZWRpcmVjdCcpLlJlZGlyZWN0XG52YXIgVHVubmVsID0gcmVxdWlyZSgnLi9saWIvdHVubmVsJykuVHVubmVsXG52YXIgbm93ID0gcmVxdWlyZSgncGVyZm9ybWFuY2Utbm93JylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgc2FmZVN0cmluZ2lmeSA9IGhlbHBlcnMuc2FmZVN0cmluZ2lmeVxudmFyIGlzUmVhZFN0cmVhbSA9IGhlbHBlcnMuaXNSZWFkU3RyZWFtXG52YXIgdG9CYXNlNjQgPSBoZWxwZXJzLnRvQmFzZTY0XG52YXIgZGVmZXIgPSBoZWxwZXJzLmRlZmVyXG52YXIgY29weSA9IGhlbHBlcnMuY29weVxudmFyIHZlcnNpb24gPSBoZWxwZXJzLnZlcnNpb25cbnZhciBnbG9iYWxDb29raWVKYXIgPSBjb29raWVzLmphcigpXG5cbnZhciBnbG9iYWxQb29sID0ge31cblxuZnVuY3Rpb24gZmlsdGVyRm9yTm9uUmVzZXJ2ZWQgKHJlc2VydmVkLCBvcHRpb25zKSB7XG4gIC8vIEZpbHRlciBvdXQgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgcmVzZXJ2ZWQuXG4gIC8vIFJlc2VydmVkIHZhbHVlcyBhcmUgcGFzc2VkIGluIGF0IGNhbGwgc2l0ZS5cblxuICB2YXIgb2JqZWN0ID0ge31cbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5vdFJlc2VydmVkID0gKHJlc2VydmVkLmluZGV4T2YoaSkgPT09IC0xKVxuICAgIGlmIChub3RSZXNlcnZlZCkge1xuICAgICAgb2JqZWN0W2ldID0gb3B0aW9uc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0XG59XG5cbmZ1bmN0aW9uIGZpbHRlck91dFJlc2VydmVkRnVuY3Rpb25zIChyZXNlcnZlZCwgb3B0aW9ucykge1xuICAvLyBGaWx0ZXIgb3V0IHByb3BlcnRpZXMgdGhhdCBhcmUgZnVuY3Rpb25zIGFuZCBhcmUgcmVzZXJ2ZWQuXG4gIC8vIFJlc2VydmVkIHZhbHVlcyBhcmUgcGFzc2VkIGluIGF0IGNhbGwgc2l0ZS5cblxuICB2YXIgb2JqZWN0ID0ge31cbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSAhKHJlc2VydmVkLmluZGV4T2YoaSkgPT09IC0xKVxuICAgIHZhciBpc0Z1bmN0aW9uID0gKHR5cGVvZiBvcHRpb25zW2ldID09PSAnZnVuY3Rpb24nKVxuICAgIGlmICghKGlzUmVzZXJ2ZWQgJiYgaXNGdW5jdGlvbikpIHtcbiAgICAgIG9iamVjdFtpXSA9IG9wdGlvbnNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdFxufVxuXG4vLyBSZXR1cm4gYSBzaW1wbGVyIHJlcXVlc3Qgb2JqZWN0IHRvIGFsbG93IHNlcmlhbGl6YXRpb25cbmZ1bmN0aW9uIHJlcXVlc3RUb0pTT04gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHtcbiAgICB1cmk6IHNlbGYudXJpLFxuICAgIG1ldGhvZDogc2VsZi5tZXRob2QsXG4gICAgaGVhZGVyczogc2VsZi5oZWFkZXJzXG4gIH1cbn1cblxuLy8gUmV0dXJuIGEgc2ltcGxlciByZXNwb25zZSBvYmplY3QgdG8gYWxsb3cgc2VyaWFsaXphdGlvblxuZnVuY3Rpb24gcmVzcG9uc2VUb0pTT04gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNDb2RlOiBzZWxmLnN0YXR1c0NvZGUsXG4gICAgYm9keTogc2VsZi5ib2R5LFxuICAgIGhlYWRlcnM6IHNlbGYuaGVhZGVycyxcbiAgICByZXF1ZXN0OiByZXF1ZXN0VG9KU09OLmNhbGwoc2VsZi5yZXF1ZXN0KVxuICB9XG59XG5cbmZ1bmN0aW9uIFJlcXVlc3QgKG9wdGlvbnMpIHtcbiAgLy8gaWYgZ2l2ZW4gdGhlIG1ldGhvZCBwcm9wZXJ0eSBpbiBvcHRpb25zLCBzZXQgcHJvcGVydHkgZXhwbGljaXRNZXRob2QgdG8gdHJ1ZVxuXG4gIC8vIGV4dGVuZCB0aGUgUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGFueSBub24tcmVzZXJ2ZWQgcHJvcGVydGllc1xuICAvLyByZW1vdmUgYW55IHJlc2VydmVkIGZ1bmN0aW9ucyBmcm9tIHRoZSBvcHRpb25zIG9iamVjdFxuICAvLyBzZXQgUmVxdWVzdCBpbnN0YW5jZSB0byBiZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbiAgLy8gY2FsbCBpbml0XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgLy8gc3RhcnQgd2l0aCBIQVIsIHRoZW4gb3ZlcnJpZGUgd2l0aCBhZGRpdGlvbmFsIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMuaGFyKSB7XG4gICAgc2VsZi5faGFyID0gbmV3IEhhcihzZWxmKVxuICAgIG9wdGlvbnMgPSBzZWxmLl9oYXIub3B0aW9ucyhvcHRpb25zKVxuICB9XG5cbiAgc3RyZWFtLlN0cmVhbS5jYWxsKHNlbGYpXG4gIHZhciByZXNlcnZlZCA9IE9iamVjdC5rZXlzKFJlcXVlc3QucHJvdG90eXBlKVxuICB2YXIgbm9uUmVzZXJ2ZWQgPSBmaWx0ZXJGb3JOb25SZXNlcnZlZChyZXNlcnZlZCwgb3B0aW9ucylcblxuICBleHRlbmQoc2VsZiwgbm9uUmVzZXJ2ZWQpXG4gIG9wdGlvbnMgPSBmaWx0ZXJPdXRSZXNlcnZlZEZ1bmN0aW9ucyhyZXNlcnZlZCwgb3B0aW9ucylcblxuICBzZWxmLnJlYWRhYmxlID0gdHJ1ZVxuICBzZWxmLndyaXRhYmxlID0gdHJ1ZVxuICBpZiAob3B0aW9ucy5tZXRob2QpIHtcbiAgICBzZWxmLmV4cGxpY2l0TWV0aG9kID0gdHJ1ZVxuICB9XG4gIHNlbGYuX3FzID0gbmV3IFF1ZXJ5c3RyaW5nKHNlbGYpXG4gIHNlbGYuX2F1dGggPSBuZXcgQXV0aChzZWxmKVxuICBzZWxmLl9vYXV0aCA9IG5ldyBPQXV0aChzZWxmKVxuICBzZWxmLl9tdWx0aXBhcnQgPSBuZXcgTXVsdGlwYXJ0KHNlbGYpXG4gIHNlbGYuX3JlZGlyZWN0ID0gbmV3IFJlZGlyZWN0KHNlbGYpXG4gIHNlbGYuX3R1bm5lbCA9IG5ldyBUdW5uZWwoc2VsZilcbiAgc2VsZi5pbml0KG9wdGlvbnMpXG59XG5cbnV0aWwuaW5oZXJpdHMoUmVxdWVzdCwgc3RyZWFtLlN0cmVhbSlcblxuLy8gRGVidWdnaW5nXG5SZXF1ZXN0LmRlYnVnID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvXFxicmVxdWVzdFxcYi8udGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuZnVuY3Rpb24gZGVidWcgKCkge1xuICBpZiAoUmVxdWVzdC5kZWJ1Zykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1JFUVVFU1QgJXMnLCB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpKVxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS5kZWJ1ZyA9IGRlYnVnXG5cblJlcXVlc3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyBpbml0KCkgY29udGFpbnMgYWxsIHRoZSBjb2RlIHRvIHNldHVwIHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgLy8gdGhlIGFjdHVhbCBvdXRnb2luZyByZXF1ZXN0IGlzIG5vdCBzdGFydGVkIHVudGlsIHN0YXJ0KCkgaXMgY2FsbGVkXG4gIC8vIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGZyb20gYm90aCB0aGUgY29uc3RydWN0b3IgYW5kIG9uIHJlZGlyZWN0LlxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cbiAgc2VsZi5oZWFkZXJzID0gc2VsZi5oZWFkZXJzID8gY29weShzZWxmLmhlYWRlcnMpIDoge31cblxuICAvLyBEZWxldGUgaGVhZGVycyB3aXRoIHZhbHVlIHVuZGVmaW5lZCBzaW5jZSB0aGV5IGJyZWFrXG4gIC8vIENsaWVudFJlcXVlc3QuT3V0Z29pbmdNZXNzYWdlLnNldEhlYWRlciBpbiBub2RlIDAuMTJcbiAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBzZWxmLmhlYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYuaGVhZGVyc1toZWFkZXJOYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlbGV0ZSBzZWxmLmhlYWRlcnNbaGVhZGVyTmFtZV1cbiAgICB9XG4gIH1cblxuICBjYXNlbGVzcy5odHRwaWZ5KHNlbGYsIHNlbGYuaGVhZGVycylcblxuICBpZiAoIXNlbGYubWV0aG9kKSB7XG4gICAgc2VsZi5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJ1xuICB9XG4gIGlmICghc2VsZi5sb2NhbEFkZHJlc3MpIHtcbiAgICBzZWxmLmxvY2FsQWRkcmVzcyA9IG9wdGlvbnMubG9jYWxBZGRyZXNzXG4gIH1cblxuICBzZWxmLl9xcy5pbml0KG9wdGlvbnMpXG5cbiAgZGVidWcob3B0aW9ucylcbiAgaWYgKCFzZWxmLnBvb2wgJiYgc2VsZi5wb29sICE9PSBmYWxzZSkge1xuICAgIHNlbGYucG9vbCA9IGdsb2JhbFBvb2xcbiAgfVxuICBzZWxmLmRlc3RzID0gc2VsZi5kZXN0cyB8fCBbXVxuICBzZWxmLl9faXNSZXF1ZXN0UmVxdWVzdCA9IHRydWVcblxuICAvLyBQcm90ZWN0IGFnYWluc3QgZG91YmxlIGNhbGxiYWNrXG4gIGlmICghc2VsZi5fY2FsbGJhY2sgJiYgc2VsZi5jYWxsYmFjaykge1xuICAgIHNlbGYuX2NhbGxiYWNrID0gc2VsZi5jYWxsYmFja1xuICAgIHNlbGYuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fY2FsbGJhY2tDYWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIC8vIFByaW50IGEgd2FybmluZyBtYXliZT9cbiAgICAgIH1cbiAgICAgIHNlbGYuX2NhbGxiYWNrQ2FsbGVkID0gdHJ1ZVxuICAgICAgc2VsZi5fY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxuICAgIH1cbiAgICBzZWxmLm9uKCdlcnJvcicsIHNlbGYuY2FsbGJhY2suYmluZCgpKVxuICAgIHNlbGYub24oJ2NvbXBsZXRlJywgc2VsZi5jYWxsYmFjay5iaW5kKHNlbGYsIG51bGwpKVxuICB9XG5cbiAgLy8gUGVvcGxlIHVzZSB0aGlzIHByb3BlcnR5IGluc3RlYWQgYWxsIHRoZSB0aW1lLCBzbyBzdXBwb3J0IGl0XG4gIGlmICghc2VsZi51cmkgJiYgc2VsZi51cmwpIHtcbiAgICBzZWxmLnVyaSA9IHNlbGYudXJsXG4gICAgZGVsZXRlIHNlbGYudXJsXG4gIH1cblxuICAvLyBJZiB0aGVyZSdzIGEgYmFzZVVybCwgdGhlbiB1c2UgaXQgYXMgdGhlIGJhc2UgVVJMIChpLmUuIHVyaSBtdXN0IGJlXG4gIC8vIHNwZWNpZmllZCBhcyBhIHJlbGF0aXZlIHBhdGggYW5kIGlzIGFwcGVuZGVkIHRvIGJhc2VVcmwpLlxuICBpZiAoc2VsZi5iYXNlVXJsKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmLmJhc2VVcmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb3B0aW9ucy5iYXNlVXJsIG11c3QgYmUgYSBzdHJpbmcnKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNlbGYudXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ29wdGlvbnMudXJpIG11c3QgYmUgYSBzdHJpbmcgd2hlbiB1c2luZyBvcHRpb25zLmJhc2VVcmwnKSlcbiAgICB9XG5cbiAgICBpZiAoc2VsZi51cmkuaW5kZXhPZignLy8nKSA9PT0gMCB8fCBzZWxmLnVyaS5pbmRleE9mKCc6Ly8nKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvcHRpb25zLnVyaSBtdXN0IGJlIGEgcGF0aCB3aGVuIHVzaW5nIG9wdGlvbnMuYmFzZVVybCcpKVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBhbGwgY2FzZXMgdG8gbWFrZSBzdXJlIHRoYXQgdGhlcmUncyBvbmx5IG9uZSBzbGFzaCBiZXR3ZWVuXG4gICAgLy8gYmFzZVVybCBhbmQgdXJpLlxuICAgIHZhciBiYXNlVXJsRW5kc1dpdGhTbGFzaCA9IHNlbGYuYmFzZVVybC5sYXN0SW5kZXhPZignLycpID09PSBzZWxmLmJhc2VVcmwubGVuZ3RoIC0gMVxuICAgIHZhciB1cmlTdGFydHNXaXRoU2xhc2ggPSBzZWxmLnVyaS5pbmRleE9mKCcvJykgPT09IDBcblxuICAgIGlmIChiYXNlVXJsRW5kc1dpdGhTbGFzaCAmJiB1cmlTdGFydHNXaXRoU2xhc2gpIHtcbiAgICAgIHNlbGYudXJpID0gc2VsZi5iYXNlVXJsICsgc2VsZi51cmkuc2xpY2UoMSlcbiAgICB9IGVsc2UgaWYgKGJhc2VVcmxFbmRzV2l0aFNsYXNoIHx8IHVyaVN0YXJ0c1dpdGhTbGFzaCkge1xuICAgICAgc2VsZi51cmkgPSBzZWxmLmJhc2VVcmwgKyBzZWxmLnVyaVxuICAgIH0gZWxzZSBpZiAoc2VsZi51cmkgPT09ICcnKSB7XG4gICAgICBzZWxmLnVyaSA9IHNlbGYuYmFzZVVybFxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnVyaSA9IHNlbGYuYmFzZVVybCArICcvJyArIHNlbGYudXJpXG4gICAgfVxuICAgIGRlbGV0ZSBzZWxmLmJhc2VVcmxcbiAgfVxuXG4gIC8vIEEgVVJJIGlzIG5lZWRlZCBieSB0aGlzIHBvaW50LCBlbWl0IGVycm9yIGlmIHdlIGhhdmVuJ3QgYmVlbiBhYmxlIHRvIGdldCBvbmVcbiAgaWYgKCFzZWxmLnVyaSkge1xuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvcHRpb25zLnVyaSBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50JykpXG4gIH1cblxuICAvLyBJZiBhIHN0cmluZyBVUkkvVVJMIHdhcyBnaXZlbiwgcGFyc2UgaXQgaW50byBhIFVSTCBvYmplY3RcbiAgaWYgKHR5cGVvZiBzZWxmLnVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWxmLnVyaSA9IHVybC5wYXJzZShzZWxmLnVyaSlcbiAgfVxuXG4gIC8vIFNvbWUgVVJMIG9iamVjdHMgYXJlIG5vdCBmcm9tIGEgVVJMIHBhcnNlZCBzdHJpbmcgYW5kIG5lZWQgaHJlZiBhZGRlZFxuICBpZiAoIXNlbGYudXJpLmhyZWYpIHtcbiAgICBzZWxmLnVyaS5ocmVmID0gdXJsLmZvcm1hdChzZWxmLnVyaSlcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQ6IFdhcm5pbmcgZm9yIHVzZXJzIG9mIHRoZSBvbGQgVW5peCBTb2NrZXRzIFVSTCBTY2hlbWVcbiAgaWYgKHNlbGYudXJpLnByb3RvY29sID09PSAndW5peDonKSB7XG4gICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2B1bml4Oi8vYCBVUkwgc2NoZW1lIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgdGhlIGZvcm1hdCBgaHR0cDovL3VuaXg6U09DS0VUOlBBVEhgJykpXG4gIH1cblxuICAvLyBTdXBwb3J0IFVuaXggU29ja2V0c1xuICBpZiAoc2VsZi51cmkuaG9zdCA9PT0gJ3VuaXgnKSB7XG4gICAgc2VsZi5lbmFibGVVbml4U29ja2V0KClcbiAgfVxuXG4gIGlmIChzZWxmLnN0cmljdFNTTCA9PT0gZmFsc2UpIHtcbiAgICBzZWxmLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlXG4gIH1cblxuICBpZiAoIXNlbGYudXJpLnBhdGhuYW1lKSB7IHNlbGYudXJpLnBhdGhuYW1lID0gJy8nIH1cblxuICBpZiAoIShzZWxmLnVyaS5ob3N0IHx8IChzZWxmLnVyaS5ob3N0bmFtZSAmJiBzZWxmLnVyaS5wb3J0KSkgJiYgIXNlbGYudXJpLmlzVW5peCkge1xuICAgIC8vIEludmFsaWQgVVJJOiBpdCBtYXkgZ2VuZXJhdGUgbG90IG9mIGJhZCBlcnJvcnMsIGxpa2UgJ1R5cGVFcnJvcjogQ2Fubm90IGNhbGwgbWV0aG9kIGBpbmRleE9mYCBvZiB1bmRlZmluZWQnIGluIENvb2tpZUphclxuICAgIC8vIERldGVjdCBhbmQgcmVqZWN0IGl0IGFzIHNvb24gYXMgcG9zc2libGVcbiAgICB2YXIgZmF1bHR5VXJpID0gdXJsLmZvcm1hdChzZWxmLnVyaSlcbiAgICB2YXIgbWVzc2FnZSA9ICdJbnZhbGlkIFVSSSBcIicgKyBmYXVsdHlVcmkgKyAnXCInXG4gICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm8gb3B0aW9uID8gVGhpcyBjYW4gYmUgdGhlIHNpZ24gb2YgYSByZWRpcmVjdFxuICAgICAgLy8gQXMgdGhpcyBpcyBhIGNhc2Ugd2hlcmUgdGhlIHVzZXIgY2Fubm90IGRvIGFueXRoaW5nICh0aGV5IGRpZG4ndCBjYWxsIHJlcXVlc3QgZGlyZWN0bHkgd2l0aCB0aGlzIFVSTClcbiAgICAgIC8vIHRoZXkgc2hvdWxkIGJlIHdhcm5lZCB0aGF0IGl0IGNhbiBiZSBjYXVzZWQgYnkgYSByZWRpcmVjdGlvbiAoY2FuIHNhdmUgc29tZSBoYWlyKVxuICAgICAgbWVzc2FnZSArPSAnLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSBjcmFwcHkgcmVkaXJlY3Rpb24uJ1xuICAgIH1cbiAgICAvLyBUaGlzIGVycm9yIHdhcyBmYXRhbFxuICAgIHNlbGYuYWJvcnQoKVxuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKVxuICB9XG5cbiAgaWYgKCFzZWxmLmhhc093blByb3BlcnR5KCdwcm94eScpKSB7XG4gICAgc2VsZi5wcm94eSA9IGdldFByb3h5RnJvbVVSSShzZWxmLnVyaSlcbiAgfVxuXG4gIHNlbGYudHVubmVsID0gc2VsZi5fdHVubmVsLmlzRW5hYmxlZCgpXG4gIGlmIChzZWxmLnByb3h5KSB7XG4gICAgc2VsZi5fdHVubmVsLnNldHVwKG9wdGlvbnMpXG4gIH1cblxuICBzZWxmLl9yZWRpcmVjdC5vblJlcXVlc3Qob3B0aW9ucylcblxuICBzZWxmLnNldEhvc3QgPSBmYWxzZVxuICBpZiAoIXNlbGYuaGFzSGVhZGVyKCdob3N0JykpIHtcbiAgICB2YXIgaG9zdEhlYWRlck5hbWUgPSBzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUgfHwgJ2hvc3QnXG4gICAgc2VsZi5zZXRIZWFkZXIoaG9zdEhlYWRlck5hbWUsIHNlbGYudXJpLmhvc3QpXG4gICAgLy8gRHJvcCA6cG9ydCBzdWZmaXggZnJvbSBIb3N0IGhlYWRlciBpZiBrbm93biBwcm90b2NvbC5cbiAgICBpZiAoc2VsZi51cmkucG9ydCkge1xuICAgICAgaWYgKChzZWxmLnVyaS5wb3J0ID09PSAnODAnICYmIHNlbGYudXJpLnByb3RvY29sID09PSAnaHR0cDonKSB8fFxuICAgICAgICAgIChzZWxmLnVyaS5wb3J0ID09PSAnNDQzJyAmJiBzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpKSB7XG4gICAgICAgIHNlbGYuc2V0SGVhZGVyKGhvc3RIZWFkZXJOYW1lLCBzZWxmLnVyaS5ob3N0bmFtZSlcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5zZXRIb3N0ID0gdHJ1ZVxuICB9XG5cbiAgc2VsZi5qYXIoc2VsZi5famFyIHx8IG9wdGlvbnMuamFyKVxuXG4gIGlmICghc2VsZi51cmkucG9ydCkge1xuICAgIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHA6JykgeyBzZWxmLnVyaS5wb3J0ID0gODAgfSBlbHNlIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHsgc2VsZi51cmkucG9ydCA9IDQ0MyB9XG4gIH1cblxuICBpZiAoc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwpIHtcbiAgICBzZWxmLnBvcnQgPSBzZWxmLnByb3h5LnBvcnRcbiAgICBzZWxmLmhvc3QgPSBzZWxmLnByb3h5Lmhvc3RuYW1lXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5wb3J0ID0gc2VsZi51cmkucG9ydFxuICAgIHNlbGYuaG9zdCA9IHNlbGYudXJpLmhvc3RuYW1lXG4gIH1cblxuICBpZiAob3B0aW9ucy5mb3JtKSB7XG4gICAgc2VsZi5mb3JtKG9wdGlvbnMuZm9ybSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmZvcm1EYXRhKSB7XG4gICAgdmFyIGZvcm1EYXRhID0gb3B0aW9ucy5mb3JtRGF0YVxuICAgIHZhciByZXF1ZXN0Rm9ybSA9IHNlbGYuZm9ybSgpXG4gICAgdmFyIGFwcGVuZEZvcm1WYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuICAgICAgICByZXF1ZXN0Rm9ybS5hcHBlbmQoa2V5LCB2YWx1ZS52YWx1ZSwgdmFsdWUub3B0aW9ucylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RGb3JtLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBmb3JtS2V5IGluIGZvcm1EYXRhKSB7XG4gICAgICBpZiAoZm9ybURhdGEuaGFzT3duUHJvcGVydHkoZm9ybUtleSkpIHtcbiAgICAgICAgdmFyIGZvcm1WYWx1ZSA9IGZvcm1EYXRhW2Zvcm1LZXldXG4gICAgICAgIGlmIChmb3JtVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9ybVZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBhcHBlbmRGb3JtVmFsdWUoZm9ybUtleSwgZm9ybVZhbHVlW2pdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBlbmRGb3JtVmFsdWUoZm9ybUtleSwgZm9ybVZhbHVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucXMpIHtcbiAgICBzZWxmLnFzKG9wdGlvbnMucXMpXG4gIH1cblxuICBpZiAoc2VsZi51cmkucGF0aCkge1xuICAgIHNlbGYucGF0aCA9IHNlbGYudXJpLnBhdGhcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnBhdGggPSBzZWxmLnVyaS5wYXRobmFtZSArIChzZWxmLnVyaS5zZWFyY2ggfHwgJycpXG4gIH1cblxuICBpZiAoc2VsZi5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHNlbGYucGF0aCA9ICcvJ1xuICB9XG5cbiAgLy8gQXV0aCBtdXN0IGhhcHBlbiBsYXN0IGluIGNhc2Ugc2lnbmluZyBpcyBkZXBlbmRlbnQgb24gb3RoZXIgaGVhZGVyc1xuICBpZiAob3B0aW9ucy5hd3MpIHtcbiAgICBzZWxmLmF3cyhvcHRpb25zLmF3cylcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhd2spIHtcbiAgICBzZWxmLmhhd2sob3B0aW9ucy5oYXdrKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuaHR0cFNpZ25hdHVyZSkge1xuICAgIHNlbGYuaHR0cFNpZ25hdHVyZShvcHRpb25zLmh0dHBTaWduYXR1cmUpXG4gIH1cblxuICBpZiAob3B0aW9ucy5hdXRoKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLmF1dGgsICd1c2VybmFtZScpKSB7XG4gICAgICBvcHRpb25zLmF1dGgudXNlciA9IG9wdGlvbnMuYXV0aC51c2VybmFtZVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMuYXV0aCwgJ3Bhc3N3b3JkJykpIHtcbiAgICAgIG9wdGlvbnMuYXV0aC5wYXNzID0gb3B0aW9ucy5hdXRoLnBhc3N3b3JkXG4gICAgfVxuXG4gICAgc2VsZi5hdXRoKFxuICAgICAgb3B0aW9ucy5hdXRoLnVzZXIsXG4gICAgICBvcHRpb25zLmF1dGgucGFzcyxcbiAgICAgIG9wdGlvbnMuYXV0aC5zZW5kSW1tZWRpYXRlbHksXG4gICAgICBvcHRpb25zLmF1dGguYmVhcmVyXG4gICAgKVxuICB9XG5cbiAgaWYgKHNlbGYuZ3ppcCAmJiAhc2VsZi5oYXNIZWFkZXIoJ2FjY2VwdC1lbmNvZGluZycpKSB7XG4gICAgc2VsZi5zZXRIZWFkZXIoJ2FjY2VwdC1lbmNvZGluZycsICdnemlwLCBkZWZsYXRlJylcbiAgfVxuXG4gIGlmIChzZWxmLnVyaS5hdXRoICYmICFzZWxmLmhhc0hlYWRlcignYXV0aG9yaXphdGlvbicpKSB7XG4gICAgdmFyIHVyaUF1dGhQaWVjZXMgPSBzZWxmLnVyaS5hdXRoLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBzZWxmLl9xcy51bmVzY2FwZShpdGVtKSB9KVxuICAgIHNlbGYuYXV0aCh1cmlBdXRoUGllY2VzWzBdLCB1cmlBdXRoUGllY2VzLnNsaWNlKDEpLmpvaW4oJzonKSwgdHJ1ZSlcbiAgfVxuXG4gIGlmICghc2VsZi50dW5uZWwgJiYgc2VsZi5wcm94eSAmJiBzZWxmLnByb3h5LmF1dGggJiYgIXNlbGYuaGFzSGVhZGVyKCdwcm94eS1hdXRob3JpemF0aW9uJykpIHtcbiAgICB2YXIgcHJveHlBdXRoUGllY2VzID0gc2VsZi5wcm94eS5hdXRoLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBzZWxmLl9xcy51bmVzY2FwZShpdGVtKSB9KVxuICAgIHZhciBhdXRoSGVhZGVyID0gJ0Jhc2ljICcgKyB0b0Jhc2U2NChwcm94eUF1dGhQaWVjZXMuam9pbignOicpKVxuICAgIHNlbGYuc2V0SGVhZGVyKCdwcm94eS1hdXRob3JpemF0aW9uJywgYXV0aEhlYWRlcilcbiAgfVxuXG4gIGlmIChzZWxmLnByb3h5ICYmICFzZWxmLnR1bm5lbCkge1xuICAgIHNlbGYucGF0aCA9IChzZWxmLnVyaS5wcm90b2NvbCArICcvLycgKyBzZWxmLnVyaS5ob3N0ICsgc2VsZi5wYXRoKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuanNvbikge1xuICAgIHNlbGYuanNvbihvcHRpb25zLmpzb24pXG4gIH1cbiAgaWYgKG9wdGlvbnMubXVsdGlwYXJ0KSB7XG4gICAgc2VsZi5tdWx0aXBhcnQob3B0aW9ucy5tdWx0aXBhcnQpXG4gIH1cblxuICBpZiAob3B0aW9ucy50aW1lKSB7XG4gICAgc2VsZi50aW1pbmcgPSB0cnVlXG5cbiAgICAvLyBOT1RFOiBlbGFwc2VkVGltZSBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIC50aW1pbmdzXG4gICAgc2VsZi5lbGFwc2VkVGltZSA9IHNlbGYuZWxhcHNlZFRpbWUgfHwgMFxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGVudExlbmd0aCAoKSB7XG4gICAgaWYgKGlzVHlwZWRBcnJheShzZWxmLmJvZHkpKSB7XG4gICAgICBzZWxmLmJvZHkgPSBCdWZmZXIuZnJvbShzZWxmLmJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLmhhc0hlYWRlcignY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgdmFyIGxlbmd0aFxuICAgICAgaWYgKHR5cGVvZiBzZWxmLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNlbGYuYm9keSlcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWxmLmJvZHkpKSB7XG4gICAgICAgIGxlbmd0aCA9IHNlbGYuYm9keS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiLmxlbmd0aCB9LCAwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gc2VsZi5ib2R5Lmxlbmd0aFxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIGxlbmd0aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0FyZ3VtZW50IGVycm9yLCBvcHRpb25zLmJvZHkuJykpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzZWxmLmJvZHkgJiYgIWlzc3RyZWFtKHNlbGYuYm9keSkpIHtcbiAgICBzZXRDb250ZW50TGVuZ3RoKClcbiAgfVxuXG4gIGlmIChvcHRpb25zLm9hdXRoKSB7XG4gICAgc2VsZi5vYXV0aChvcHRpb25zLm9hdXRoKVxuICB9IGVsc2UgaWYgKHNlbGYuX29hdXRoLnBhcmFtcyAmJiBzZWxmLmhhc0hlYWRlcignYXV0aG9yaXphdGlvbicpKSB7XG4gICAgc2VsZi5vYXV0aChzZWxmLl9vYXV0aC5wYXJhbXMpXG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSBzZWxmLnByb3h5ICYmICFzZWxmLnR1bm5lbCA/IHNlbGYucHJveHkucHJvdG9jb2wgOiBzZWxmLnVyaS5wcm90b2NvbFxuICB2YXIgZGVmYXVsdE1vZHVsZXMgPSB7J2h0dHA6JzogaHR0cCwgJ2h0dHBzOic6IGh0dHBzfVxuICB2YXIgaHR0cE1vZHVsZXMgPSBzZWxmLmh0dHBNb2R1bGVzIHx8IHt9XG5cbiAgc2VsZi5odHRwTW9kdWxlID0gaHR0cE1vZHVsZXNbcHJvdG9jb2xdIHx8IGRlZmF1bHRNb2R1bGVzW3Byb3RvY29sXVxuXG4gIGlmICghc2VsZi5odHRwTW9kdWxlKSB7XG4gICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2w6ICcgKyBwcm90b2NvbCkpXG4gIH1cblxuICBpZiAob3B0aW9ucy5jYSkge1xuICAgIHNlbGYuY2EgPSBvcHRpb25zLmNhXG4gIH1cblxuICBpZiAoIXNlbGYuYWdlbnQpIHtcbiAgICBpZiAob3B0aW9ucy5hZ2VudE9wdGlvbnMpIHtcbiAgICAgIHNlbGYuYWdlbnRPcHRpb25zID0gb3B0aW9ucy5hZ2VudE9wdGlvbnNcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hZ2VudENsYXNzKSB7XG4gICAgICBzZWxmLmFnZW50Q2xhc3MgPSBvcHRpb25zLmFnZW50Q2xhc3NcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9yZXZlcikge1xuICAgICAgdmFyIHYgPSB2ZXJzaW9uKClcbiAgICAgIC8vIHVzZSBGb3JldmVyQWdlbnQgaW4gbm9kZSAwLjEwLSBvbmx5XG4gICAgICBpZiAodi5tYWpvciA9PT0gMCAmJiB2Lm1pbm9yIDw9IDEwKSB7XG4gICAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IHByb3RvY29sID09PSAnaHR0cDonID8gRm9yZXZlckFnZW50IDogRm9yZXZlckFnZW50LlNTTFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5hZ2VudENsYXNzID0gc2VsZi5odHRwTW9kdWxlLkFnZW50XG4gICAgICAgIHNlbGYuYWdlbnRPcHRpb25zID0gc2VsZi5hZ2VudE9wdGlvbnMgfHwge31cbiAgICAgICAgc2VsZi5hZ2VudE9wdGlvbnMua2VlcEFsaXZlID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFnZW50Q2xhc3MgPSBzZWxmLmh0dHBNb2R1bGUuQWdlbnRcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5wb29sID09PSBmYWxzZSkge1xuICAgIHNlbGYuYWdlbnQgPSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHNlbGYuYWdlbnQgPSBzZWxmLmFnZW50IHx8IHNlbGYuZ2V0TmV3QWdlbnQoKVxuICB9XG5cbiAgc2VsZi5vbigncGlwZScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICBpZiAoc2VsZi5udGljayAmJiBzZWxmLl9zdGFydGVkKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdZb3UgY2Fubm90IHBpcGUgdG8gdGhpcyBzdHJlYW0gYWZ0ZXIgdGhlIG91dGJvdW5kIHJlcXVlc3QgaGFzIHN0YXJ0ZWQuJykpXG4gICAgfVxuICAgIHNlbGYuc3JjID0gc3JjXG4gICAgaWYgKGlzUmVhZFN0cmVhbShzcmMpKSB7XG4gICAgICBpZiAoIXNlbGYuaGFzSGVhZGVyKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgbWltZS5sb29rdXAoc3JjLnBhdGgpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjLmhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzcmMuaGVhZGVycykge1xuICAgICAgICAgIGlmICghc2VsZi5oYXNIZWFkZXIoaSkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0SGVhZGVyKGksIHNyYy5oZWFkZXJzW2ldKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYuX2pzb24gJiYgIXNlbGYuaGFzSGVhZGVyKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgICAgfVxuICAgICAgaWYgKHNyYy5tZXRob2QgJiYgIXNlbGYuZXhwbGljaXRNZXRob2QpIHtcbiAgICAgICAgc2VsZi5tZXRob2QgPSBzcmMubWV0aG9kXG4gICAgICB9XG4gICAgfVxuXG4gIC8vIHNlbGYub24oJ3BpcGUnLCBmdW5jdGlvbiAoKSB7XG4gIC8vICAgY29uc29sZS5lcnJvcignWW91IGhhdmUgYWxyZWFkeSBwaXBlZCB0byB0aGlzIHN0cmVhbS4gUGlwZWluZyB0d2ljZSBpcyBsaWtlbHkgdG8gYnJlYWsgdGhlIHJlcXVlc3QuJylcbiAgLy8gfSlcbiAgfSlcblxuICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2Fib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fZm9ybSkge1xuICAgICAgICBpZiAoIXNlbGYuX2F1dGguaGFzQXV0aCkge1xuICAgICAgICAgIHNlbGYuX2Zvcm0ucGlwZShzZWxmKVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuX2F1dGguaGFzQXV0aCAmJiBzZWxmLl9hdXRoLnNlbnRBdXRoKSB7XG4gICAgICAgICAgc2VsZi5fZm9ybS5waXBlKHNlbGYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLl9tdWx0aXBhcnQgJiYgc2VsZi5fbXVsdGlwYXJ0LmNodW5rZWQpIHtcbiAgICAgICAgc2VsZi5fbXVsdGlwYXJ0LmJvZHkucGlwZShzZWxmKVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYuYm9keSkge1xuICAgICAgICBpZiAoaXNzdHJlYW0oc2VsZi5ib2R5KSkge1xuICAgICAgICAgIHNlbGYuYm9keS5waXBlKHNlbGYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0Q29udGVudExlbmd0aCgpXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZi5ib2R5KSkge1xuICAgICAgICAgICAgc2VsZi5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgc2VsZi53cml0ZShwYXJ0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cml0ZShzZWxmLmJvZHkpXG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuZW5kKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxmLnJlcXVlc3RCb2R5U3RyZWFtKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybignb3B0aW9ucy5yZXF1ZXN0Qm9keVN0cmVhbSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgcGFzcyB0aGUgcmVxdWVzdCBvYmplY3QgdG8gc3RyZWFtLnBpcGUuJylcbiAgICAgICAgc2VsZi5yZXF1ZXN0Qm9keVN0cmVhbS5waXBlKHNlbGYpXG4gICAgICB9IGVsc2UgaWYgKCFzZWxmLnNyYykge1xuICAgICAgICBpZiAoc2VsZi5fYXV0aC5oYXNBdXRoICYmICFzZWxmLl9hdXRoLnNlbnRBdXRoKSB7XG4gICAgICAgICAgc2VsZi5lbmQoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm1ldGhvZCAhPT0gJ0dFVCcgJiYgdHlwZW9mIHNlbGYubWV0aG9kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIDApXG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lbmQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9mb3JtICYmICFzZWxmLmhhc0hlYWRlcignY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgLy8gQmVmb3JlIGVuZGluZyB0aGUgcmVxdWVzdCwgd2UgaGFkIHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgd2hvbGUgZm9ybSwgYXN5bmNseVxuICAgICAgc2VsZi5zZXRIZWFkZXIoc2VsZi5fZm9ybS5nZXRIZWFkZXJzKCksIHRydWUpXG4gICAgICBzZWxmLl9mb3JtLmdldExlbmd0aChmdW5jdGlvbiAoZXJyLCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCFlcnIgJiYgIWlzTmFOKGxlbmd0aCkpIHtcbiAgICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCBsZW5ndGgpXG4gICAgICAgIH1cbiAgICAgICAgZW5kKClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCgpXG4gICAgfVxuXG4gICAgc2VsZi5udGljayA9IHRydWVcbiAgfSlcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0TmV3QWdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgQWdlbnQgPSBzZWxmLmFnZW50Q2xhc3NcbiAgdmFyIG9wdGlvbnMgPSB7fVxuICBpZiAoc2VsZi5hZ2VudE9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpIGluIHNlbGYuYWdlbnRPcHRpb25zKSB7XG4gICAgICBvcHRpb25zW2ldID0gc2VsZi5hZ2VudE9wdGlvbnNbaV1cbiAgICB9XG4gIH1cbiAgaWYgKHNlbGYuY2EpIHtcbiAgICBvcHRpb25zLmNhID0gc2VsZi5jYVxuICB9XG4gIGlmIChzZWxmLmNpcGhlcnMpIHtcbiAgICBvcHRpb25zLmNpcGhlcnMgPSBzZWxmLmNpcGhlcnNcbiAgfVxuICBpZiAoc2VsZi5zZWN1cmVQcm90b2NvbCkge1xuICAgIG9wdGlvbnMuc2VjdXJlUHJvdG9jb2wgPSBzZWxmLnNlY3VyZVByb3RvY29sXG4gIH1cbiAgaWYgKHNlbGYuc2VjdXJlT3B0aW9ucykge1xuICAgIG9wdGlvbnMuc2VjdXJlT3B0aW9ucyA9IHNlbGYuc2VjdXJlT3B0aW9uc1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZi5yZWplY3RVbmF1dGhvcml6ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSBzZWxmLnJlamVjdFVuYXV0aG9yaXplZFxuICB9XG5cbiAgaWYgKHNlbGYuY2VydCAmJiBzZWxmLmtleSkge1xuICAgIG9wdGlvbnMua2V5ID0gc2VsZi5rZXlcbiAgICBvcHRpb25zLmNlcnQgPSBzZWxmLmNlcnRcbiAgfVxuXG4gIGlmIChzZWxmLnBmeCkge1xuICAgIG9wdGlvbnMucGZ4ID0gc2VsZi5wZnhcbiAgfVxuXG4gIGlmIChzZWxmLnBhc3NwaHJhc2UpIHtcbiAgICBvcHRpb25zLnBhc3NwaHJhc2UgPSBzZWxmLnBhc3NwaHJhc2VcbiAgfVxuXG4gIHZhciBwb29sS2V5ID0gJydcblxuICAvLyBkaWZmZXJlbnQgdHlwZXMgb2YgYWdlbnRzIGFyZSBpbiBkaWZmZXJlbnQgcG9vbHNcbiAgaWYgKEFnZW50ICE9PSBzZWxmLmh0dHBNb2R1bGUuQWdlbnQpIHtcbiAgICBwb29sS2V5ICs9IEFnZW50Lm5hbWVcbiAgfVxuXG4gIC8vIGNhIG9wdGlvbiBpcyBvbmx5IHJlbGV2YW50IGlmIHByb3h5IG9yIGRlc3RpbmF0aW9uIGFyZSBodHRwc1xuICB2YXIgcHJveHkgPSBzZWxmLnByb3h5XG4gIGlmICh0eXBlb2YgcHJveHkgPT09ICdzdHJpbmcnKSB7XG4gICAgcHJveHkgPSB1cmwucGFyc2UocHJveHkpXG4gIH1cbiAgdmFyIGlzSHR0cHMgPSAocHJveHkgJiYgcHJveHkucHJvdG9jb2wgPT09ICdodHRwczonKSB8fCB0aGlzLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOidcblxuICBpZiAoaXNIdHRwcykge1xuICAgIGlmIChvcHRpb25zLmNhKSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLmNhXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2VydCkge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5jZXJ0LnRvU3RyaW5nKCdhc2NpaScpICsgb3B0aW9ucy5rZXkudG9TdHJpbmcoJ2FzY2lpJylcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZngpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMucGZ4LnRvU3RyaW5nKCdhc2NpaScpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2lwaGVycykge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5jaXBoZXJzXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlUHJvdG9jb2wpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuc2VjdXJlUHJvdG9jb2xcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVPcHRpb25zKSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLnNlY3VyZU9wdGlvbnNcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5wb29sID09PSBnbG9iYWxQb29sICYmICFwb29sS2V5ICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCAmJiBzZWxmLmh0dHBNb2R1bGUuZ2xvYmFsQWdlbnQpIHtcbiAgICAvLyBub3QgZG9pbmcgYW55dGhpbmcgc3BlY2lhbC4gIFVzZSB0aGUgZ2xvYmFsQWdlbnRcbiAgICByZXR1cm4gc2VsZi5odHRwTW9kdWxlLmdsb2JhbEFnZW50XG4gIH1cblxuICAvLyB3ZSdyZSB1c2luZyBhIHN0b3JlZCBhZ2VudC4gIE1ha2Ugc3VyZSBpdCdzIHByb3RvY29sLXNwZWNpZmljXG4gIHBvb2xLZXkgPSBzZWxmLnVyaS5wcm90b2NvbCArIHBvb2xLZXlcblxuICAvLyBnZW5lcmF0ZSBhIG5ldyBhZ2VudCBmb3IgdGhpcyBzZXR0aW5nIGlmIG5vbmUgeWV0IGV4aXN0c1xuICBpZiAoIXNlbGYucG9vbFtwb29sS2V5XSkge1xuICAgIHNlbGYucG9vbFtwb29sS2V5XSA9IG5ldyBBZ2VudChvcHRpb25zKVxuICAgIC8vIHByb3Blcmx5IHNldCBtYXhTb2NrZXRzIG9uIG5ldyBhZ2VudHNcbiAgICBpZiAoc2VsZi5wb29sLm1heFNvY2tldHMpIHtcbiAgICAgIHNlbGYucG9vbFtwb29sS2V5XS5tYXhTb2NrZXRzID0gc2VsZi5wb29sLm1heFNvY2tldHNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZi5wb29sW3Bvb2xLZXldXG59XG5cblJlcXVlc3QucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBzdGFydCgpIGlzIGNhbGxlZCBvbmNlIHdlIGFyZSByZWFkeSB0byBzZW5kIHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3QuXG4gIC8vIHRoaXMgaXMgdXN1YWxseSBjYWxsZWQgb24gdGhlIGZpcnN0IHdyaXRlKCksIGVuZCgpIG9yIG9uIG5leHRUaWNrKClcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYudGltaW5nKSB7XG4gICAgLy8gQWxsIHRpbWluZ3Mgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzIHJlcXVlc3QncyBzdGFydFRpbWUuICBJbiBvcmRlciB0byBkbyB0aGlzLFxuICAgIC8vIHdlIG5lZWQgdG8gY2FwdHVyZSB0aGUgd2FsbC1jbG9jayBzdGFydCB0aW1lICh2aWEgRGF0ZSksIGltbWVkaWF0ZWx5IGZvbGxvd2VkXG4gICAgLy8gYnkgdGhlIGhpZ2gtcmVzb2x1dGlvbiB0aW1lciAodmlhIG5vdygpKS4gIFdoaWxlIHRoZXNlIHR3byB3b24ndCBiZSBzZXRcbiAgICAvLyBhdCB0aGUgX2V4YWN0XyBzYW1lIHRpbWUsIHRoZXkgc2hvdWxkIGJlIGNsb3NlIGVub3VnaCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZVxuICAgIC8vIGhpZ2gtcmVzb2x1dGlvbiwgbW9ub3RvbmljYWxseSBub24tZGVjcmVhc2luZyB0aW1lc3RhbXBzIHJlbGF0aXZlIHRvIHN0YXJ0VGltZS5cbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICB2YXIgc3RhcnRUaW1lTm93ID0gbm93KClcbiAgfVxuXG4gIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmLl9zdGFydGVkID0gdHJ1ZVxuICBzZWxmLm1ldGhvZCA9IHNlbGYubWV0aG9kIHx8ICdHRVQnXG4gIHNlbGYuaHJlZiA9IHNlbGYudXJpLmhyZWZcblxuICBpZiAoc2VsZi5zcmMgJiYgc2VsZi5zcmMuc3RhdCAmJiBzZWxmLnNyYy5zdGF0LnNpemUgJiYgIXNlbGYuaGFzSGVhZGVyKCdjb250ZW50LWxlbmd0aCcpKSB7XG4gICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgc2VsZi5zcmMuc3RhdC5zaXplKVxuICB9XG4gIGlmIChzZWxmLl9hd3MpIHtcbiAgICBzZWxmLmF3cyhzZWxmLl9hd3MsIHRydWUpXG4gIH1cblxuICAvLyBXZSBoYXZlIGEgbWV0aG9kIG5hbWVkIGF1dGgsIHdoaWNoIGlzIGNvbXBsZXRlbHkgZGlmZmVyZW50IGZyb20gdGhlIGh0dHAucmVxdWVzdFxuICAvLyBhdXRoIG9wdGlvbi4gIElmIHdlIGRvbid0IHJlbW92ZSBpdCwgd2UncmUgZ29ubmEgaGF2ZSBhIGJhZCB0aW1lLlxuICB2YXIgcmVxT3B0aW9ucyA9IGNvcHkoc2VsZilcbiAgZGVsZXRlIHJlcU9wdGlvbnMuYXV0aFxuXG4gIGRlYnVnKCdtYWtlIHJlcXVlc3QnLCBzZWxmLnVyaS5ocmVmKVxuXG4gIC8vIG5vZGUgdjYuOC4wIG5vdyBzdXBwb3J0cyBhIGB0aW1lb3V0YCB2YWx1ZSBpbiBgaHR0cC5yZXF1ZXN0KClgLCBidXQgd2VcbiAgLy8gc2hvdWxkIGRlbGV0ZSBpdCBmb3Igbm93IHNpbmNlIHdlIGhhbmRsZSB0aW1lb3V0cyBtYW51YWxseSBmb3IgYmV0dGVyXG4gIC8vIGNvbnNpc3RlbmN5IHdpdGggbm9kZSB2ZXJzaW9ucyBiZWZvcmUgdjYuOC4wXG4gIGRlbGV0ZSByZXFPcHRpb25zLnRpbWVvdXRcblxuICB0cnkge1xuICAgIHNlbGYucmVxID0gc2VsZi5odHRwTW9kdWxlLnJlcXVlc3QocmVxT3B0aW9ucylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzZWxmLnRpbWluZykge1xuICAgIHNlbGYuc3RhcnRUaW1lID0gc3RhcnRUaW1lXG4gICAgc2VsZi5zdGFydFRpbWVOb3cgPSBzdGFydFRpbWVOb3dcblxuICAgIC8vIFRpbWluZyB2YWx1ZXMgd2lsbCBhbGwgYmUgcmVsYXRpdmUgdG8gc3RhcnRUaW1lIChieSBjb21wYXJpbmcgdG8gc3RhcnRUaW1lTm93XG4gICAgLy8gc28gd2UgaGF2ZSBhbiBhY2N1cmF0ZSBjbG9jaylcbiAgICBzZWxmLnRpbWluZ3MgPSB7fVxuICB9XG5cbiAgdmFyIHRpbWVvdXRcbiAgaWYgKHNlbGYudGltZW91dCAmJiAhc2VsZi50aW1lb3V0VGltZXIpIHtcbiAgICBpZiAoc2VsZi50aW1lb3V0IDwgMCkge1xuICAgICAgdGltZW91dCA9IDBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmLnRpbWVvdXQgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHNlbGYudGltZW91dCkpIHtcbiAgICAgIHRpbWVvdXQgPSBzZWxmLnRpbWVvdXRcbiAgICB9XG4gIH1cblxuICBzZWxmLnJlcS5vbigncmVzcG9uc2UnLCBzZWxmLm9uUmVxdWVzdFJlc3BvbnNlLmJpbmQoc2VsZikpXG4gIHNlbGYucmVxLm9uKCdlcnJvcicsIHNlbGYub25SZXF1ZXN0RXJyb3IuYmluZChzZWxmKSlcbiAgc2VsZi5yZXEub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKVxuICB9KVxuXG4gIHNlbGYucmVxLm9uKCdzb2NrZXQnLCBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgLy8gYC5fY29ubmVjdGluZ2Agd2FzIHRoZSBvbGQgcHJvcGVydHkgd2hpY2ggd2FzIG1hZGUgcHVibGljIGluIG5vZGUgdjYuMS4wXG4gICAgdmFyIGlzQ29ubmVjdGluZyA9IHNvY2tldC5fY29ubmVjdGluZyB8fCBzb2NrZXQuY29ubmVjdGluZ1xuICAgIGlmIChzZWxmLnRpbWluZykge1xuICAgICAgc2VsZi50aW1pbmdzLnNvY2tldCA9IG5vdygpIC0gc2VsZi5zdGFydFRpbWVOb3dcblxuICAgICAgaWYgKGlzQ29ubmVjdGluZykge1xuICAgICAgICB2YXIgb25Mb29rdXBUaW1pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi50aW1pbmdzLmxvb2t1cCA9IG5vdygpIC0gc2VsZi5zdGFydFRpbWVOb3dcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbkNvbm5lY3RUaW1pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi50aW1pbmdzLmNvbm5lY3QgPSBub3coKSAtIHNlbGYuc3RhcnRUaW1lTm93XG4gICAgICAgIH1cblxuICAgICAgICBzb2NrZXQub25jZSgnbG9va3VwJywgb25Mb29rdXBUaW1pbmcpXG4gICAgICAgIHNvY2tldC5vbmNlKCdjb25uZWN0Jywgb25Db25uZWN0VGltaW5nKVxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHRpbWluZyBldmVudCBsaXN0ZW5lcnMgaWYgbmVlZGVkIG9uIGVycm9yXG4gICAgICAgIHNlbGYucmVxLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignbG9va3VwJywgb25Mb29rdXBUaW1pbmcpXG4gICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0Jywgb25Db25uZWN0VGltaW5nKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzZXRSZXFUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVGhpcyB0aW1lb3V0IHNldHMgdGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgKmJldHdlZW4qIGJ5dGVzIHNlbnRcbiAgICAgIC8vIGZyb20gdGhlIHNlcnZlciBvbmNlIGNvbm5lY3RlZC5cbiAgICAgIC8vXG4gICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBpdCdzIHVzZWZ1bCBmb3IgZXJyb3JpbmcgaWYgdGhlIHNlcnZlciBmYWlscyB0byBzZW5kXG4gICAgICAvLyBkYXRhIGhhbGZ3YXkgdGhyb3VnaCBzdHJlYW1pbmcgYSByZXNwb25zZS5cbiAgICAgIHNlbGYucmVxLnNldFRpbWVvdXQodGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5yZXEpIHtcbiAgICAgICAgICBzZWxmLmFib3J0KClcbiAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignRVNPQ0tFVFRJTUVET1VUJylcbiAgICAgICAgICBlLmNvZGUgPSAnRVNPQ0tFVFRJTUVET1VUJ1xuICAgICAgICAgIGUuY29ubmVjdCA9IGZhbHNlXG4gICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGlmICh0aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9ubHkgc3RhcnQgdGhlIGNvbm5lY3Rpb24gdGltZXIgaWYgd2UncmUgYWN0dWFsbHkgY29ubmVjdGluZyBhIG5ld1xuICAgICAgLy8gc29ja2V0LCBvdGhlcndpc2UgaWYgd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQgKGJlY2F1c2UgdGhpcyBpcyBhXG4gICAgICAvLyBrZWVwLWFsaXZlIGNvbm5lY3Rpb24pIGRvIG5vdCBib3RoZXIuIFRoaXMgaXMgaW1wb3J0YW50IHNpbmNlIHdlIHdvbid0XG4gICAgICAvLyBnZXQgYSAnY29ubmVjdCcgZXZlbnQgZm9yIGFuIGFscmVhZHkgY29ubmVjdGVkIHNvY2tldC5cbiAgICAgIGlmIChpc0Nvbm5lY3RpbmcpIHtcbiAgICAgICAgdmFyIG9uUmVxU29ja0Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0Jywgb25SZXFTb2NrQ29ubmVjdClcbiAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCgpXG4gICAgICAgICAgc2V0UmVxVGltZW91dCgpXG4gICAgICAgIH1cblxuICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBvblJlcVNvY2tDb25uZWN0KVxuXG4gICAgICAgIHNlbGYucmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBoYW5kbGUtY2FsbGJhY2stZXJyXG4gICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0Jywgb25SZXFTb2NrQ29ubmVjdClcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBTZXQgYSB0aW1lb3V0IGluIG1lbW9yeSAtIHRoaXMgYmxvY2sgd2lsbCB0aHJvdyBpZiB0aGUgc2VydmVyIHRha2VzIG1vcmVcbiAgICAgICAgLy8gdGhhbiBgdGltZW91dGAgdG8gd3JpdGUgdGhlIEhUVFAgc3RhdHVzIGFuZCBoZWFkZXJzIChjb3JyZXNwb25kaW5nIHRvXG4gICAgICAgIC8vIHRoZSBvbigncmVzcG9uc2UnKSBldmVudCBvbiB0aGUgY2xpZW50KS4gTkI6IHRoaXMgbWVhc3VyZXMgd2FsbC1jbG9ja1xuICAgICAgICAvLyB0aW1lLCBub3QgdGhlIHRpbWUgYmV0d2VlbiBieXRlcyBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICAgIHNlbGYudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0Jywgb25SZXFTb2NrQ29ubmVjdClcbiAgICAgICAgICBzZWxmLmFib3J0KClcbiAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcignRVRJTUVET1VUJylcbiAgICAgICAgICBlLmNvZGUgPSAnRVRJTUVET1VUJ1xuICAgICAgICAgIGUuY29ubmVjdCA9IHRydWVcbiAgICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSlcbiAgICAgICAgfSwgdGltZW91dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3JlIGFscmVhZHkgY29ubmVjdGVkXG4gICAgICAgIHNldFJlcVRpbWVvdXQoKVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ3NvY2tldCcsIHNvY2tldClcbiAgfSlcblxuICBzZWxmLmVtaXQoJ3JlcXVlc3QnLCBzZWxmLnJlcSlcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUub25SZXF1ZXN0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHNlbGYucmVxICYmIHNlbGYucmVxLl9yZXVzZWRTb2NrZXQgJiYgZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnICYmXG4gICAgc2VsZi5hZ2VudC5hZGRSZXF1ZXN0Tm9yZXVzZSkge1xuICAgIHNlbGYuYWdlbnQgPSB7IGFkZFJlcXVlc3Q6IHNlbGYuYWdlbnQuYWRkUmVxdWVzdE5vcmV1c2UuYmluZChzZWxmLmFnZW50KSB9XG4gICAgc2VsZi5zdGFydCgpXG4gICAgc2VsZi5yZXEuZW5kKClcbiAgICByZXR1cm5cbiAgfVxuICBzZWxmLmNsZWFyVGltZW91dCgpXG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcilcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUub25SZXF1ZXN0UmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYudGltaW5nKSB7XG4gICAgc2VsZi50aW1pbmdzLnJlc3BvbnNlID0gbm93KCkgLSBzZWxmLnN0YXJ0VGltZU5vd1xuICB9XG5cbiAgZGVidWcoJ29uUmVxdWVzdFJlc3BvbnNlJywgc2VsZi51cmkuaHJlZiwgcmVzcG9uc2Uuc3RhdHVzQ29kZSwgcmVzcG9uc2UuaGVhZGVycylcbiAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi50aW1pbmcpIHtcbiAgICAgIHNlbGYudGltaW5ncy5lbmQgPSBub3coKSAtIHNlbGYuc3RhcnRUaW1lTm93XG4gICAgICByZXNwb25zZS50aW1pbmdTdGFydCA9IHNlbGYuc3RhcnRUaW1lXG5cbiAgICAgIC8vIGZpbGwgaW4gdGhlIGJsYW5rcyBmb3IgYW55IHBlcmlvZHMgdGhhdCBkaWRuJ3QgdHJpZ2dlciwgc3VjaCBhc1xuICAgICAgLy8gbm8gbG9va3VwIG9yIGNvbm5lY3QgZHVlIHRvIGtlZXAgYWxpdmVcbiAgICAgIGlmICghc2VsZi50aW1pbmdzLnNvY2tldCkge1xuICAgICAgICBzZWxmLnRpbWluZ3Muc29ja2V0ID0gMFxuICAgICAgfVxuICAgICAgaWYgKCFzZWxmLnRpbWluZ3MubG9va3VwKSB7XG4gICAgICAgIHNlbGYudGltaW5ncy5sb29rdXAgPSBzZWxmLnRpbWluZ3Muc29ja2V0XG4gICAgICB9XG4gICAgICBpZiAoIXNlbGYudGltaW5ncy5jb25uZWN0KSB7XG4gICAgICAgIHNlbGYudGltaW5ncy5jb25uZWN0ID0gc2VsZi50aW1pbmdzLmxvb2t1cFxuICAgICAgfVxuICAgICAgaWYgKCFzZWxmLnRpbWluZ3MucmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi50aW1pbmdzLnJlc3BvbnNlID0gc2VsZi50aW1pbmdzLmNvbm5lY3RcbiAgICAgIH1cblxuICAgICAgZGVidWcoJ2VsYXBzZWQgdGltZScsIHNlbGYudGltaW5ncy5lbmQpXG5cbiAgICAgIC8vIGVsYXBzZWRUaW1lIGluY2x1ZGVzIGFsbCByZWRpcmVjdHNcbiAgICAgIHNlbGYuZWxhcHNlZFRpbWUgKz0gTWF0aC5yb3VuZChzZWxmLnRpbWluZ3MuZW5kKVxuXG4gICAgICAvLyBOT1RFOiBlbGFwc2VkVGltZSBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIC50aW1pbmdzXG4gICAgICByZXNwb25zZS5lbGFwc2VkVGltZSA9IHNlbGYuZWxhcHNlZFRpbWVcblxuICAgICAgLy8gdGltaW5ncyBpcyBqdXN0IGZvciB0aGUgZmluYWwgZmV0Y2hcbiAgICAgIHJlc3BvbnNlLnRpbWluZ3MgPSBzZWxmLnRpbWluZ3NcblxuICAgICAgLy8gcHJlLWNhbGN1bGF0ZSBwaGFzZSB0aW1pbmdzIGFzIHdlbGxcbiAgICAgIHJlc3BvbnNlLnRpbWluZ1BoYXNlcyA9IHtcbiAgICAgICAgd2FpdDogc2VsZi50aW1pbmdzLnNvY2tldCxcbiAgICAgICAgZG5zOiBzZWxmLnRpbWluZ3MubG9va3VwIC0gc2VsZi50aW1pbmdzLnNvY2tldCxcbiAgICAgICAgdGNwOiBzZWxmLnRpbWluZ3MuY29ubmVjdCAtIHNlbGYudGltaW5ncy5sb29rdXAsXG4gICAgICAgIGZpcnN0Qnl0ZTogc2VsZi50aW1pbmdzLnJlc3BvbnNlIC0gc2VsZi50aW1pbmdzLmNvbm5lY3QsXG4gICAgICAgIGRvd25sb2FkOiBzZWxmLnRpbWluZ3MuZW5kIC0gc2VsZi50aW1pbmdzLnJlc3BvbnNlLFxuICAgICAgICB0b3RhbDogc2VsZi50aW1pbmdzLmVuZFxuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1ZygncmVzcG9uc2UgZW5kJywgc2VsZi51cmkuaHJlZiwgcmVzcG9uc2Uuc3RhdHVzQ29kZSwgcmVzcG9uc2UuaGVhZGVycylcbiAgfSlcblxuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICByZXNwb25zZS5yZXN1bWUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgc2VsZi5yZXNwb25zZSA9IHJlc3BvbnNlXG4gIHJlc3BvbnNlLnJlcXVlc3QgPSBzZWxmXG4gIHJlc3BvbnNlLnRvSlNPTiA9IHJlc3BvbnNlVG9KU09OXG5cbiAgLy8gWFhYIFRoaXMgaXMgZGlmZmVyZW50IG9uIDAuMTAsIGJlY2F1c2UgU1NMIGlzIHN0cmljdCBieSBkZWZhdWx0XG4gIGlmIChzZWxmLmh0dHBNb2R1bGUgPT09IGh0dHBzICYmXG4gICAgc2VsZi5zdHJpY3RTU0wgJiYgKCFyZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgnc29ja2V0JykgfHxcbiAgICAhcmVzcG9uc2Uuc29ja2V0LmF1dGhvcml6ZWQpKSB7XG4gICAgZGVidWcoJ3N0cmljdCBzc2wgZXJyb3InLCBzZWxmLnVyaS5ocmVmKVxuICAgIHZhciBzc2xFcnIgPSByZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgnc29ja2V0JykgPyByZXNwb25zZS5zb2NrZXQuYXV0aG9yaXphdGlvbkVycm9yIDogc2VsZi51cmkuaHJlZiArICcgZG9lcyBub3Qgc3VwcG9ydCBTU0wnXG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignU1NMIEVycm9yOiAnICsgc3NsRXJyKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFNhdmUgdGhlIG9yaWdpbmFsIGhvc3QgYmVmb3JlIGFueSByZWRpcmVjdCAoaWYgaXQgY2hhbmdlcywgd2UgbmVlZCB0b1xuICAvLyByZW1vdmUgYW55IGF1dGhvcml6YXRpb24gaGVhZGVycykuICBBbHNvIHJlbWVtYmVyIHRoZSBjYXNlIG9mIHRoZSBoZWFkZXJcbiAgLy8gbmFtZSBiZWNhdXNlIGxvdHMgb2YgYnJva2VuIHNlcnZlcnMgZXhwZWN0IEhvc3QgaW5zdGVhZCBvZiBob3N0IGFuZCB3ZVxuICAvLyB3YW50IHRoZSBjYWxsZXIgdG8gYmUgYWJsZSB0byBzcGVjaWZ5IHRoaXMuXG4gIHNlbGYub3JpZ2luYWxIb3N0ID0gc2VsZi5nZXRIZWFkZXIoJ2hvc3QnKVxuICBpZiAoIXNlbGYub3JpZ2luYWxIb3N0SGVhZGVyTmFtZSkge1xuICAgIHNlbGYub3JpZ2luYWxIb3N0SGVhZGVyTmFtZSA9IHNlbGYuaGFzSGVhZGVyKCdob3N0JylcbiAgfVxuICBpZiAoc2VsZi5zZXRIb3N0KSB7XG4gICAgc2VsZi5yZW1vdmVIZWFkZXIoJ2hvc3QnKVxuICB9XG4gIHNlbGYuY2xlYXJUaW1lb3V0KClcblxuICB2YXIgdGFyZ2V0Q29va2llSmFyID0gKHNlbGYuX2phciAmJiBzZWxmLl9qYXIuc2V0Q29va2llKSA/IHNlbGYuX2phciA6IGdsb2JhbENvb2tpZUphclxuICB2YXIgYWRkQ29va2llID0gZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgIC8vIHNldCB0aGUgY29va2llIGlmIGl0J3MgZG9tYWluIGluIHRoZSBocmVmJ3MgZG9tYWluLlxuICAgIHRyeSB7XG4gICAgICB0YXJnZXRDb29raWVKYXIuc2V0Q29va2llKGNvb2tpZSwgc2VsZi51cmkuaHJlZiwge2lnbm9yZUVycm9yOiB0cnVlfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSlcbiAgICB9XG4gIH1cblxuICByZXNwb25zZS5jYXNlbGVzcyA9IGNhc2VsZXNzKHJlc3BvbnNlLmhlYWRlcnMpXG5cbiAgaWYgKHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnc2V0LWNvb2tpZScpICYmICghc2VsZi5fZGlzYWJsZUNvb2tpZXMpKSB7XG4gICAgdmFyIGhlYWRlck5hbWUgPSByZXNwb25zZS5jYXNlbGVzcy5oYXMoJ3NldC1jb29raWUnKVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyTmFtZV0pKSB7XG4gICAgICByZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdLmZvckVhY2goYWRkQ29va2llKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDb29raWUocmVzcG9uc2UuaGVhZGVyc1toZWFkZXJOYW1lXSlcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5fcmVkaXJlY3Qub25SZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICByZXR1cm4gLy8gSWdub3JlIHRoZSByZXN0IG9mIHRoZSByZXNwb25zZVxuICB9IGVsc2Uge1xuICAgIC8vIEJlIGEgZ29vZCBzdHJlYW0gYW5kIGVtaXQgZW5kIHdoZW4gdGhlIHJlc3BvbnNlIGlzIGZpbmlzaGVkLlxuICAgIC8vIEhhY2sgdG8gZW1pdCBlbmQgb24gY2xvc2UgYmVjYXVzZSBvZiBhIGNvcmUgYnVnIHRoYXQgbmV2ZXIgZmlyZXMgZW5kXG4gICAgcmVzcG9uc2Uub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmLl9lbmRlZCkge1xuICAgICAgICBzZWxmLnJlc3BvbnNlLmVtaXQoJ2VuZCcpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJlc3BvbnNlLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuX2VuZGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICB2YXIgbm9Cb2R5ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHNlbGYubWV0aG9kID09PSAnSEVBRCcgfHxcbiAgICAgICAgLy8gSW5mb3JtYXRpb25hbFxuICAgICAgICAoY29kZSA+PSAxMDAgJiYgY29kZSA8IDIwMCkgfHxcbiAgICAgICAgLy8gTm8gQ29udGVudFxuICAgICAgICBjb2RlID09PSAyMDQgfHxcbiAgICAgICAgLy8gTm90IE1vZGlmaWVkXG4gICAgICAgIGNvZGUgPT09IDMwNFxuICAgICAgKVxuICAgIH1cblxuICAgIHZhciByZXNwb25zZUNvbnRlbnRcbiAgICBpZiAoc2VsZi5nemlwICYmICFub0JvZHkocmVzcG9uc2Uuc3RhdHVzQ29kZSkpIHtcbiAgICAgIHZhciBjb250ZW50RW5jb2RpbmcgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gfHwgJ2lkZW50aXR5J1xuICAgICAgY29udGVudEVuY29kaW5nID0gY29udGVudEVuY29kaW5nLnRyaW0oKS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIC8vIEJlIG1vcmUgbGVuaWVudCB3aXRoIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSAodmVyeSByYXJlbHkpXG4gICAgICAvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCBnemlwIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuICAgICAgLy8gYnkgY29tbW9uIGJyb3dzZXJzLlxuICAgICAgLy8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cbiAgICAgIHZhciB6bGliT3B0aW9ucyA9IHtcbiAgICAgICAgZmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNILFxuICAgICAgICBmaW5pc2hGbHVzaDogemxpYi5aX1NZTkNfRkxVU0hcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgIHJlc3BvbnNlQ29udGVudCA9IHpsaWIuY3JlYXRlR3VuemlwKHpsaWJPcHRpb25zKVxuICAgICAgICByZXNwb25zZS5waXBlKHJlc3BvbnNlQ29udGVudClcbiAgICAgIH0gZWxzZSBpZiAoY29udGVudEVuY29kaW5nID09PSAnZGVmbGF0ZScpIHtcbiAgICAgICAgcmVzcG9uc2VDb250ZW50ID0gemxpYi5jcmVhdGVJbmZsYXRlKHpsaWJPcHRpb25zKVxuICAgICAgICByZXNwb25zZS5waXBlKHJlc3BvbnNlQ29udGVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmNlIHByZXZpb3VzIHZlcnNpb25zIGRpZG4ndCBjaGVjayBmb3IgQ29udGVudC1FbmNvZGluZyBoZWFkZXIsXG4gICAgICAgIC8vIGlnbm9yZSBhbnkgaW52YWxpZCB2YWx1ZXMgdG8gcHJlc2VydmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgIGRlYnVnKCdpZ25vcmluZyB1bnJlY29nbml6ZWQgQ29udGVudC1FbmNvZGluZyAnICsgY29udGVudEVuY29kaW5nKVxuICAgICAgICB9XG4gICAgICAgIHJlc3BvbnNlQ29udGVudCA9IHJlc3BvbnNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3BvbnNlQ29udGVudCA9IHJlc3BvbnNlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuZW5jb2RpbmcpIHtcbiAgICAgIGlmIChzZWxmLmRlc3RzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJZ25vcmluZyBlbmNvZGluZyBwYXJhbWV0ZXIgYXMgdGhpcyBzdHJlYW0gaXMgYmVpbmcgcGlwZWQgdG8gYW5vdGhlciBzdHJlYW0gd2hpY2ggbWFrZXMgdGhlIGVuY29kaW5nIG9wdGlvbiBpbnZhbGlkLicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZUNvbnRlbnQuc2V0RW5jb2Rpbmcoc2VsZi5lbmNvZGluZylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fcGF1c2VkKSB7XG4gICAgICByZXNwb25zZUNvbnRlbnQucGF1c2UoKVxuICAgIH1cblxuICAgIHNlbGYucmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2VDb250ZW50XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzcG9uc2UpXG5cbiAgICBzZWxmLmRlc3RzLmZvckVhY2goZnVuY3Rpb24gKGRlc3QpIHtcbiAgICAgIHNlbGYucGlwZURlc3QoZGVzdClcbiAgICB9KVxuXG4gICAgcmVzcG9uc2VDb250ZW50Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBpZiAoc2VsZi50aW1pbmcgJiYgIXNlbGYucmVzcG9uc2VTdGFydGVkKSB7XG4gICAgICAgIHNlbGYucmVzcG9uc2VTdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpXG5cbiAgICAgICAgLy8gTk9URTogcmVzcG9uc2VTdGFydFRpbWUgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiAudGltaW5nc1xuICAgICAgICByZXNwb25zZS5yZXNwb25zZVN0YXJ0VGltZSA9IHNlbGYucmVzcG9uc2VTdGFydFRpbWVcbiAgICAgIH1cbiAgICAgIHNlbGYuX2Rlc3RkYXRhID0gdHJ1ZVxuICAgICAgc2VsZi5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgfSlcbiAgICByZXNwb25zZUNvbnRlbnQub25jZSgnZW5kJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzZWxmLmVtaXQoJ2VuZCcsIGNodW5rKVxuICAgIH0pXG4gICAgcmVzcG9uc2VDb250ZW50Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgIH0pXG4gICAgcmVzcG9uc2VDb250ZW50Lm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHsgc2VsZi5lbWl0KCdjbG9zZScpIH0pXG5cbiAgICBpZiAoc2VsZi5jYWxsYmFjaykge1xuICAgICAgc2VsZi5yZWFkUmVzcG9uc2VCb2R5KHJlc3BvbnNlKVxuICAgIH0gZWxzZSB7IC8vIGlmIG5vIGNhbGxiYWNrXG4gICAgICBzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgICAgICAgZGVidWcoJ2Fib3J0ZWQnLCBzZWxmLnVyaS5ocmVmKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW1pdCgnY29tcGxldGUnLCByZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGRlYnVnKCdmaW5pc2ggaW5pdCBmdW5jdGlvbicsIHNlbGYudXJpLmhyZWYpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLnJlYWRSZXNwb25zZUJvZHkgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKFwicmVhZGluZyByZXNwb25zZSdzIGJvZHlcIilcbiAgdmFyIGJ1ZmZlcnMgPSBbXVxuICB2YXIgYnVmZmVyTGVuZ3RoID0gMFxuICB2YXIgc3RyaW5ncyA9IFtdXG5cbiAgc2VsZi5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgc3RyaW5ncy5wdXNoKGNodW5rKVxuICAgIH0gZWxzZSBpZiAoY2h1bmsubGVuZ3RoKSB7XG4gICAgICBidWZmZXJMZW5ndGggKz0gY2h1bmsubGVuZ3RoXG4gICAgICBidWZmZXJzLnB1c2goY2h1bmspXG4gICAgfVxuICB9KVxuICBzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ2VuZCBldmVudCcsIHNlbGYudXJpLmhyZWYpXG4gICAgaWYgKHNlbGYuX2Fib3J0ZWQpIHtcbiAgICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICAgIC8vIGBidWZmZXJgIGlzIGRlZmluZWQgaW4gdGhlIHBhcmVudCBzY29wZSBhbmQgdXNlZCBpbiBhIGNsb3N1cmUgaXQgZXhpc3RzIGZvciB0aGUgbGlmZSBvZiB0aGUgcmVxdWVzdC5cbiAgICAgIC8vIFRoaXMgY2FuIGxlYWQgdG8gbGVha3kgYmVoYXZpb3IgaWYgdGhlIHVzZXIgcmV0YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgcmVxdWVzdCBvYmplY3QuXG4gICAgICBidWZmZXJzID0gW11cbiAgICAgIGJ1ZmZlckxlbmd0aCA9IDBcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChidWZmZXJMZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdoYXMgYm9keScsIHNlbGYudXJpLmhyZWYsIGJ1ZmZlckxlbmd0aClcbiAgICAgIHJlc3BvbnNlLmJvZHkgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIGJ1ZmZlckxlbmd0aClcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNlLmJvZHkgPSByZXNwb25zZS5ib2R5LnRvU3RyaW5nKHNlbGYuZW5jb2RpbmcpXG4gICAgICB9XG4gICAgICAvLyBgYnVmZmVyYCBpcyBkZWZpbmVkIGluIHRoZSBwYXJlbnQgc2NvcGUgYW5kIHVzZWQgaW4gYSBjbG9zdXJlIGl0IGV4aXN0cyBmb3IgdGhlIGxpZmUgb2YgdGhlIFJlcXVlc3QuXG4gICAgICAvLyBUaGlzIGNhbiBsZWFkIHRvIGxlYWt5IGJlaGF2aW9yIGlmIHRoZSB1c2VyIHJldGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAgYnVmZmVycyA9IFtdXG4gICAgICBidWZmZXJMZW5ndGggPSAwXG4gICAgfSBlbHNlIGlmIChzdHJpbmdzLmxlbmd0aCkge1xuICAgICAgLy8gVGhlIFVURjggQk9NIFsweEVGLDB4QkIsMHhCRl0gaXMgY29udmVydGVkIHRvIFsweEZFLDB4RkZdIGluIHRoZSBKUyBVVEMxNi9VQ1MyIHJlcHJlc2VudGF0aW9uLlxuICAgICAgLy8gU3RyaXAgdGhpcyB2YWx1ZSBvdXQgd2hlbiB0aGUgZW5jb2RpbmcgaXMgc2V0IHRvICd1dGY4JywgYXMgdXBzdHJlYW0gY29uc3VtZXJzIHdvbid0IGV4cGVjdCBpdCBhbmQgaXQgYnJlYWtzIEpTT04ucGFyc2UoKS5cbiAgICAgIGlmIChzZWxmLmVuY29kaW5nID09PSAndXRmOCcgJiYgc3RyaW5nc1swXS5sZW5ndGggPiAwICYmIHN0cmluZ3NbMF1bMF0gPT09ICdcXHVGRUZGJykge1xuICAgICAgICBzdHJpbmdzWzBdID0gc3RyaW5nc1swXS5zdWJzdHJpbmcoMSlcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLmJvZHkgPSBzdHJpbmdzLmpvaW4oJycpXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2pzb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlLmJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHksIHNlbGYuX2pzb25SZXZpdmVyKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBKU09OIHJlY2VpdmVkJywgc2VsZi51cmkuaHJlZilcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoJ2VtaXR0aW5nIGNvbXBsZXRlJywgc2VsZi51cmkuaHJlZilcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmJvZHkgPT09ICd1bmRlZmluZWQnICYmICFzZWxmLl9qc29uKSB7XG4gICAgICByZXNwb25zZS5ib2R5ID0gc2VsZi5lbmNvZGluZyA9PT0gbnVsbCA/IEJ1ZmZlci5hbGxvYygwKSA6ICcnXG4gICAgfVxuICAgIHNlbGYuZW1pdCgnY29tcGxldGUnLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgfSlcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9hYm9ydGVkID0gdHJ1ZVxuXG4gIGlmIChzZWxmLnJlcSkge1xuICAgIHNlbGYucmVxLmFib3J0KClcbiAgfSBlbHNlIGlmIChzZWxmLnJlc3BvbnNlKSB7XG4gICAgc2VsZi5yZXNwb25zZS5kZXN0cm95KClcbiAgfVxuXG4gIHNlbGYuY2xlYXJUaW1lb3V0KClcbiAgc2VsZi5lbWl0KCdhYm9ydCcpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLnBpcGVEZXN0ID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXNwb25zZSA9IHNlbGYucmVzcG9uc2VcbiAgLy8gQ2FsbGVkIGFmdGVyIHRoZSByZXNwb25zZSBpcyByZWNlaXZlZFxuICBpZiAoZGVzdC5oZWFkZXJzICYmICFkZXN0LmhlYWRlcnNTZW50KSB7XG4gICAgaWYgKHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnY29udGVudC10eXBlJykpIHtcbiAgICAgIHZhciBjdG5hbWUgPSByZXNwb25zZS5jYXNlbGVzcy5oYXMoJ2NvbnRlbnQtdHlwZScpXG4gICAgICBpZiAoZGVzdC5zZXRIZWFkZXIpIHtcbiAgICAgICAgZGVzdC5zZXRIZWFkZXIoY3RuYW1lLCByZXNwb25zZS5oZWFkZXJzW2N0bmFtZV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LmhlYWRlcnNbY3RuYW1lXSA9IHJlc3BvbnNlLmhlYWRlcnNbY3RuYW1lXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5jYXNlbGVzcy5oYXMoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIHZhciBjbG5hbWUgPSByZXNwb25zZS5jYXNlbGVzcy5oYXMoJ2NvbnRlbnQtbGVuZ3RoJylcbiAgICAgIGlmIChkZXN0LnNldEhlYWRlcikge1xuICAgICAgICBkZXN0LnNldEhlYWRlcihjbG5hbWUsIHJlc3BvbnNlLmhlYWRlcnNbY2xuYW1lXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QuaGVhZGVyc1tjbG5hbWVdID0gcmVzcG9uc2UuaGVhZGVyc1tjbG5hbWVdXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkZXN0LnNldEhlYWRlciAmJiAhZGVzdC5oZWFkZXJzU2VudCkge1xuICAgIGZvciAodmFyIGkgaW4gcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGNvbnRlbnQgaXMgYmVpbmcgZGVjb2RlZCwgdGhlIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyXG4gICAgICAvLyBvZiB0aGUgcmVzcG9uc2UgZG9lc24ndCByZXByZXNlbnQgdGhlIHBpcGVkIGNvbnRlbnQsIHNvIGRvbid0IHBhc3MgaXQuXG4gICAgICBpZiAoIXNlbGYuZ3ppcCB8fCBpICE9PSAnY29udGVudC1lbmNvZGluZycpIHtcbiAgICAgICAgZGVzdC5zZXRIZWFkZXIoaSwgcmVzcG9uc2UuaGVhZGVyc1tpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgZGVzdC5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZVxuICB9XG4gIGlmIChzZWxmLnBpcGVmaWx0ZXIpIHtcbiAgICBzZWxmLnBpcGVmaWx0ZXIocmVzcG9uc2UsIGRlc3QpXG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUucXMgPSBmdW5jdGlvbiAocSwgY2xvYmJlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGJhc2VcbiAgaWYgKCFjbG9iYmVyICYmIHNlbGYudXJpLnF1ZXJ5KSB7XG4gICAgYmFzZSA9IHNlbGYuX3FzLnBhcnNlKHNlbGYudXJpLnF1ZXJ5KVxuICB9IGVsc2Uge1xuICAgIGJhc2UgPSB7fVxuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBxKSB7XG4gICAgYmFzZVtpXSA9IHFbaV1cbiAgfVxuXG4gIHZhciBxcyA9IHNlbGYuX3FzLnN0cmluZ2lmeShiYXNlKVxuXG4gIGlmIChxcyA9PT0gJycpIHtcbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgc2VsZi51cmkgPSB1cmwucGFyc2Uoc2VsZi51cmkuaHJlZi5zcGxpdCgnPycpWzBdICsgJz8nICsgcXMpXG4gIHNlbGYudXJsID0gc2VsZi51cmlcbiAgc2VsZi5wYXRoID0gc2VsZi51cmkucGF0aFxuXG4gIGlmIChzZWxmLnVyaS5ob3N0ID09PSAndW5peCcpIHtcbiAgICBzZWxmLmVuYWJsZVVuaXhTb2NrZXQoKVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmZvcm0gPSBmdW5jdGlvbiAoZm9ybSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKGZvcm0pIHtcbiAgICBpZiAoIS9eYXBwbGljYXRpb25cXC94LXd3dy1mb3JtLXVybGVuY29kZWRcXGIvLnRlc3Qoc2VsZi5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKVxuICAgIH1cbiAgICBzZWxmLmJvZHkgPSAodHlwZW9mIGZvcm0gPT09ICdzdHJpbmcnKVxuICAgICAgPyBzZWxmLl9xcy5yZmMzOTg2KGZvcm0udG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICAgIDogc2VsZi5fcXMuc3RyaW5naWZ5KGZvcm0pLnRvU3RyaW5nKCd1dGY4JylcbiAgICByZXR1cm4gc2VsZlxuICB9XG4gIC8vIGNyZWF0ZSBmb3JtLWRhdGEgb2JqZWN0XG4gIHNlbGYuX2Zvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBzZWxmLl9mb3JtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBlcnIubWVzc2FnZSA9ICdmb3JtLWRhdGE6ICcgKyBlcnIubWVzc2FnZVxuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgc2VsZi5hYm9ydCgpXG4gIH0pXG4gIHJldHVybiBzZWxmLl9mb3JtXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5tdWx0aXBhcnQgPSBmdW5jdGlvbiAobXVsdGlwYXJ0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuX211bHRpcGFydC5vblJlcXVlc3QobXVsdGlwYXJ0KVxuXG4gIGlmICghc2VsZi5fbXVsdGlwYXJ0LmNodW5rZWQpIHtcbiAgICBzZWxmLmJvZHkgPSBzZWxmLl9tdWx0aXBhcnQuYm9keVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghc2VsZi5oYXNIZWFkZXIoJ2FjY2VwdCcpKSB7XG4gICAgc2VsZi5zZXRIZWFkZXIoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZi5qc29uUmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLl9qc29uUmVwbGFjZXIgPSBzZWxmLmpzb25SZXBsYWNlclxuICB9XG5cbiAgc2VsZi5fanNvbiA9IHRydWVcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIGlmIChzZWxmLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCEvXmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkXFxiLy50ZXN0KHNlbGYuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSkpIHtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2FmZVN0cmluZ2lmeShzZWxmLmJvZHksIHNlbGYuX2pzb25SZXBsYWNlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuYm9keSA9IHNlbGYuX3FzLnJmYzM5ODYoc2VsZi5ib2R5KVxuICAgICAgfVxuICAgICAgaWYgKCFzZWxmLmhhc0hlYWRlcignY29udGVudC10eXBlJykpIHtcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5ib2R5ID0gc2FmZVN0cmluZ2lmeSh2YWwsIHNlbGYuX2pzb25SZXBsYWNlcilcbiAgICBpZiAoIXNlbGYuaGFzSGVhZGVyKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYuanNvblJldml2ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWxmLl9qc29uUmV2aXZlciA9IHNlbGYuanNvblJldml2ZXJcbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgaGVhZGVycykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlc3VsdCwgcmUsIG1hdGNoXG4gIGlmICghaGVhZGVycykge1xuICAgIGhlYWRlcnMgPSBzZWxmLmhlYWRlcnNcbiAgfVxuICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gbmFtZS5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZSA9IG5ldyBSZWdFeHAobmFtZSwgJ2knKVxuICAgIG1hdGNoID0ga2V5Lm1hdGNoKHJlKVxuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmVzdWx0ID0gaGVhZGVyc1trZXldXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5SZXF1ZXN0LnByb3RvdHlwZS5lbmFibGVVbml4U29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBHZXQgdGhlIHNvY2tldCAmIHJlcXVlc3QgcGF0aHMgZnJvbSB0aGUgVVJMXG4gIHZhciB1bml4UGFydHMgPSB0aGlzLnVyaS5wYXRoLnNwbGl0KCc6JylcbiAgdmFyIGhvc3QgPSB1bml4UGFydHNbMF1cbiAgdmFyIHBhdGggPSB1bml4UGFydHNbMV1cbiAgLy8gQXBwbHkgdW5peCBwcm9wZXJ0aWVzIHRvIHJlcXVlc3RcbiAgdGhpcy5zb2NrZXRQYXRoID0gaG9zdFxuICB0aGlzLnVyaS5wYXRobmFtZSA9IHBhdGhcbiAgdGhpcy51cmkucGF0aCA9IHBhdGhcbiAgdGhpcy51cmkuaG9zdCA9IGhvc3RcbiAgdGhpcy51cmkuaG9zdG5hbWUgPSBob3N0XG4gIHRoaXMudXJpLmlzVW5peCA9IHRydWVcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHksIGJlYXJlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9hdXRoLm9uUmVxdWVzdCh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHksIGJlYXJlcilcblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuYXdzID0gZnVuY3Rpb24gKG9wdHMsIG5vdykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoIW5vdykge1xuICAgIHNlbGYuX2F3cyA9IG9wdHNcbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgaWYgKG9wdHMuc2lnbl92ZXJzaW9uID09PSA0IHx8IG9wdHMuc2lnbl92ZXJzaW9uID09PSAnNCcpIHtcbiAgICAvLyB1c2UgYXdzNFxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogc2VsZi51cmkuaG9zdCxcbiAgICAgIHBhdGg6IHNlbGYudXJpLnBhdGgsXG4gICAgICBtZXRob2Q6IHNlbGYubWV0aG9kLFxuICAgICAgaGVhZGVyczogc2VsZi5oZWFkZXJzLFxuICAgICAgYm9keTogc2VsZi5ib2R5XG4gICAgfVxuICAgIGlmIChvcHRzLnNlcnZpY2UpIHtcbiAgICAgIG9wdGlvbnMuc2VydmljZSA9IG9wdHMuc2VydmljZVxuICAgIH1cbiAgICB2YXIgc2lnblJlcyA9IGF3czQuc2lnbihvcHRpb25zLCB7XG4gICAgICBhY2Nlc3NLZXlJZDogb3B0cy5rZXksXG4gICAgICBzZWNyZXRBY2Nlc3NLZXk6IG9wdHMuc2VjcmV0LFxuICAgICAgc2Vzc2lvblRva2VuOiBvcHRzLnNlc3Npb25cbiAgICB9KVxuICAgIHNlbGYuc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgc2lnblJlcy5oZWFkZXJzLkF1dGhvcml6YXRpb24pXG4gICAgc2VsZi5zZXRIZWFkZXIoJ3gtYW16LWRhdGUnLCBzaWduUmVzLmhlYWRlcnNbJ1gtQW16LURhdGUnXSlcbiAgICBpZiAoc2lnblJlcy5oZWFkZXJzWydYLUFtei1TZWN1cml0eS1Ub2tlbiddKSB7XG4gICAgICBzZWxmLnNldEhlYWRlcigneC1hbXotc2VjdXJpdHktdG9rZW4nLCBzaWduUmVzLmhlYWRlcnNbJ1gtQW16LVNlY3VyaXR5LVRva2VuJ10pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRlZmF1bHQ6IHVzZSBhd3Mtc2lnbjJcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKClcbiAgICBzZWxmLnNldEhlYWRlcignZGF0ZScsIGRhdGUudG9VVENTdHJpbmcoKSlcbiAgICB2YXIgYXV0aCA9IHtcbiAgICAgIGtleTogb3B0cy5rZXksXG4gICAgICBzZWNyZXQ6IG9wdHMuc2VjcmV0LFxuICAgICAgdmVyYjogc2VsZi5tZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgIGRhdGU6IGRhdGUsXG4gICAgICBjb250ZW50VHlwZTogc2VsZi5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpIHx8ICcnLFxuICAgICAgbWQ1OiBzZWxmLmdldEhlYWRlcignY29udGVudC1tZDUnKSB8fCAnJyxcbiAgICAgIGFtYXpvbkhlYWRlcnM6IGF3czIuY2Fub25pY2FsaXplSGVhZGVycyhzZWxmLmhlYWRlcnMpXG4gICAgfVxuICAgIHZhciBwYXRoID0gc2VsZi51cmkucGF0aFxuICAgIGlmIChvcHRzLmJ1Y2tldCAmJiBwYXRoKSB7XG4gICAgICBhdXRoLnJlc291cmNlID0gJy8nICsgb3B0cy5idWNrZXQgKyBwYXRoXG4gICAgfSBlbHNlIGlmIChvcHRzLmJ1Y2tldCAmJiAhcGF0aCkge1xuICAgICAgYXV0aC5yZXNvdXJjZSA9ICcvJyArIG9wdHMuYnVja2V0XG4gICAgfSBlbHNlIGlmICghb3B0cy5idWNrZXQgJiYgcGF0aCkge1xuICAgICAgYXV0aC5yZXNvdXJjZSA9IHBhdGhcbiAgICB9IGVsc2UgaWYgKCFvcHRzLmJ1Y2tldCAmJiAhcGF0aCkge1xuICAgICAgYXV0aC5yZXNvdXJjZSA9ICcvJ1xuICAgIH1cbiAgICBhdXRoLnJlc291cmNlID0gYXdzMi5jYW5vbmljYWxpemVSZXNvdXJjZShhdXRoLnJlc291cmNlKVxuICAgIHNlbGYuc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXdzMi5hdXRob3JpemF0aW9uKGF1dGgpKVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmh0dHBTaWduYXR1cmUgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaHR0cFNpZ25hdHVyZS5zaWduUmVxdWVzdCh7XG4gICAgZ2V0SGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRIZWFkZXIoaGVhZGVyLCBzZWxmLmhlYWRlcnMpXG4gICAgfSxcbiAgICBzZXRIZWFkZXI6IGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gICAgICBzZWxmLnNldEhlYWRlcihoZWFkZXIsIHZhbHVlKVxuICAgIH0sXG4gICAgbWV0aG9kOiBzZWxmLm1ldGhvZCxcbiAgICBwYXRoOiBzZWxmLnBhdGhcbiAgfSwgb3B0cylcbiAgZGVidWcoJ2h0dHBTaWduYXR1cmUgYXV0aG9yaXphdGlvbicsIHNlbGYuZ2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJykpXG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmhhd2sgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBoYXdrLmhlYWRlcihzZWxmLnVyaSwgc2VsZi5tZXRob2QsIG9wdHMpKVxufVxuUmVxdWVzdC5wcm90b3R5cGUub2F1dGggPSBmdW5jdGlvbiAoX29hdXRoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuX29hdXRoLm9uUmVxdWVzdChfb2F1dGgpXG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuamFyID0gZnVuY3Rpb24gKGphcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGNvb2tpZXNcblxuICBpZiAoc2VsZi5fcmVkaXJlY3QucmVkaXJlY3RzRm9sbG93ZWQgPT09IDApIHtcbiAgICBzZWxmLm9yaWdpbmFsQ29va2llSGVhZGVyID0gc2VsZi5nZXRIZWFkZXIoJ2Nvb2tpZScpXG4gIH1cblxuICBpZiAoIWphcikge1xuICAgIC8vIGRpc2FibGUgY29va2llc1xuICAgIGNvb2tpZXMgPSBmYWxzZVxuICAgIHNlbGYuX2Rpc2FibGVDb29raWVzID0gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXRDb29raWVKYXIgPSBqYXIuZ2V0Q29va2llU3RyaW5nID8gamFyIDogZ2xvYmFsQ29va2llSmFyXG4gICAgdmFyIHVyaWhyZWYgPSBzZWxmLnVyaS5ocmVmXG4gICAgLy8gZmV0Y2ggY29va2llIGluIHRoZSBTcGVjaWZpZWQgaG9zdFxuICAgIGlmICh0YXJnZXRDb29raWVKYXIpIHtcbiAgICAgIGNvb2tpZXMgPSB0YXJnZXRDb29raWVKYXIuZ2V0Q29va2llU3RyaW5nKHVyaWhyZWYpXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgbmVlZCBjb29raWUgYW5kIGNvb2tpZSBpcyBub3QgZW1wdHlcbiAgaWYgKGNvb2tpZXMgJiYgY29va2llcy5sZW5ndGgpIHtcbiAgICBpZiAoc2VsZi5vcmlnaW5hbENvb2tpZUhlYWRlcikge1xuICAgICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIENvb2tpZSBoZWFkZXJcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb29raWUnLCBzZWxmLm9yaWdpbmFsQ29va2llSGVhZGVyICsgJzsgJyArIGNvb2tpZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb29raWUnLCBjb29raWVzKVxuICAgIH1cbiAgfVxuICBzZWxmLl9qYXIgPSBqYXJcbiAgcmV0dXJuIHNlbGZcbn1cblxuLy8gU3RyZWFtIEFQSVxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChzZWxmLnJlc3BvbnNlKSB7XG4gICAgaWYgKHNlbGYuX2Rlc3RkYXRhKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdZb3UgY2Fubm90IHBpcGUgYWZ0ZXIgZGF0YSBoYXMgYmVlbiBlbWl0dGVkIGZyb20gdGhlIHJlc3BvbnNlLicpKVxuICAgIH0gZWxzZSBpZiAoc2VsZi5fZW5kZWQpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcGlwZSBhZnRlciB0aGUgcmVzcG9uc2UgaGFzIGJlZW4gZW5kZWQuJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5TdHJlYW0ucHJvdG90eXBlLnBpcGUuY2FsbChzZWxmLCBkZXN0LCBvcHRzKVxuICAgICAgc2VsZi5waXBlRGVzdChkZXN0KVxuICAgICAgcmV0dXJuIGRlc3RcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5kZXN0cy5wdXNoKGRlc3QpXG4gICAgc3RyZWFtLlN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHNlbGYsIGRlc3QsIG9wdHMpXG4gICAgcmV0dXJuIGRlc3RcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5fYWJvcnRlZCkgeyByZXR1cm4gfVxuXG4gIGlmICghc2VsZi5fc3RhcnRlZCkge1xuICAgIHNlbGYuc3RhcnQoKVxuICB9XG4gIGlmIChzZWxmLnJlcSkge1xuICAgIHJldHVybiBzZWxmLnJlcS53cml0ZS5hcHBseShzZWxmLnJlcSwgYXJndW1lbnRzKVxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLl9hYm9ydGVkKSB7IHJldHVybiB9XG5cbiAgaWYgKGNodW5rKSB7XG4gICAgc2VsZi53cml0ZShjaHVuaylcbiAgfVxuICBpZiAoIXNlbGYuX3N0YXJ0ZWQpIHtcbiAgICBzZWxmLnN0YXJ0KClcbiAgfVxuICBpZiAoc2VsZi5yZXEpIHtcbiAgICBzZWxmLnJlcS5lbmQoKVxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5yZXNwb25zZUNvbnRlbnQpIHtcbiAgICBzZWxmLl9wYXVzZWQgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZXNwb25zZUNvbnRlbnQucGF1c2UuYXBwbHkoc2VsZi5yZXNwb25zZUNvbnRlbnQsIGFyZ3VtZW50cylcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLnJlc3BvbnNlQ29udGVudCkge1xuICAgIHNlbGYuX3BhdXNlZCA9IGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZXNwb25zZUNvbnRlbnQucmVzdW1lLmFwcGx5KHNlbGYucmVzcG9uc2VDb250ZW50LCBhcmd1bWVudHMpXG4gIH1cbn1cblJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLmNsZWFyVGltZW91dCgpXG4gIGlmICghc2VsZi5fZW5kZWQpIHtcbiAgICBzZWxmLmVuZCgpXG4gIH0gZWxzZSBpZiAoc2VsZi5yZXNwb25zZSkge1xuICAgIHNlbGYucmVzcG9uc2UuZGVzdHJveSgpXG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsXG4gIH1cbn1cblxuUmVxdWVzdC5kZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPVxuICBUdW5uZWwuZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0LnNsaWNlKClcblxuUmVxdWVzdC5kZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID1cbiAgVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3Quc2xpY2UoKVxuXG4vLyBFeHBvcnRzXG5cblJlcXVlc3QucHJvdG90eXBlLnRvSlNPTiA9IHJlcXVlc3RUb0pTT05cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/request/request.js\n");

/***/ })

};
;